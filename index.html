<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DID Key Recovery Specification (DID-KR) · Sirraya Labs</title>
    
    <!-- Mermaid for diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    
    <!-- Syntax highlighting for code blocks -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <style>
        /* Sirraya Labs custom styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.7;
            color: #1a2b3c;
            background: #f8fafc;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background: white;
            box-shadow: 0 20px 40px rgba(0,0,0,0.05);
        }
        
        /* Sirraya Labs header */
        .sirraya-header {
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 2px solid #e9ecef;
        }
        
        .sirraya-logo {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .sirraya-logo svg {
            width: 50px;
            height: 50px;
        }
        
        .sirraya-title h1 {
            font-size: 2.5rem;
            font-weight: 600;
            background: linear-gradient(135deg, #2563eb, #7c3aed);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }
        
        .sirraya-title .subtitle {
            font-size: 1.2rem;
            color: #64748b;
        }
        
        .metadata {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            background: #f1f5f9;
            padding: 1.5rem;
            border-radius: 12px;
            margin: 2rem 0;
        }
        
        .metadata-item {
            flex: 1;
            min-width: 200px;
        }
        
        .metadata-item .label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #64748b;
            margin-bottom: 0.25rem;
        }
        
        .metadata-item .value {
            font-size: 1.1rem;
            font-weight: 500;
            color: #0f172a;
        }
        
        /* Typography */
        h2 {
            font-size: 2rem;
            font-weight: 600;
            color: #0f172a;
            margin: 3rem 0 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 3px solid #e2e8f0;
        }
        
        h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1e293b;
            margin: 2rem 0 1rem;
        }
        
        h4 {
            font-size: 1.25rem;
            font-weight: 500;
            color: #334155;
            margin: 1.5rem 0 0.75rem;
        }
        
        p {
            margin-bottom: 1.25rem;
            color: #334155;
        }
        
        ul, ol {
            margin: 1rem 0 1.5rem 1.5rem;
            color: #334155;
        }
        
        li {
            margin-bottom: 0.5rem;
        }
        
        a {
            color: #2563eb;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        /* Code blocks */
        pre {
            background: #0f172a;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 12px;
            overflow-x: auto;
            font-family: 'Fira Code', 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 1.5rem 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        code {
            font-family: 'Fira Code', 'JetBrains Mono', monospace;
            background: #f1f5f9;
            color: #0f172a;
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        pre code {
            background: transparent;
            color: inherit;
            padding: 0;
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        
        th {
            background: #1e293b;
            color: white;
            font-weight: 600;
            padding: 1rem;
            text-align: left;
        }
        
        td {
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
        }
        
        tr:last-child td {
            border-bottom: none;
        }
        
        tr:hover td {
            background: #f8fafc;
        }
        
        /* Diagrams */
        .diagram-container {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 8px 16px rgba(0,0,0,0.05);
        }
        
        .diagram-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #0f172a;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .mermaid {
            background: white;
            text-align: center;
        }
        
        /* Notes and callouts */
        .note {
            background: #fef9c3;
            border-left: 4px solid #eab308;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 12px 12px 0;
        }
        
        .warning {
            background: #fee2e2;
            border-left: 4px solid #ef4444;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 12px 12px 0;
        }
        
        .algorithm {
            background: #f1f5f9;
            padding: 1.5rem;
            border-radius: 12px;
            font-family: 'Fira Code', monospace;
            border: 1px solid #cbd5e1;
            margin: 1.5rem 0;
        }
        
        /* Footer */
        .footer {
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 2px solid #e2e8f0;
            text-align: center;
            color: #64748b;
            font-size: 0.9rem;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .metadata {
                flex-direction: column;
                gap: 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
        }

        .example {
            background: #0f172a;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 12px;
            overflow-x: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            margin: 1.5rem 0;
        }

        dt {
            font-weight: 600;
            color: #0f172a;
            margin-top: 1rem;
        }

        dd {
            margin-left: 1.5rem;
            margin-bottom: 0.5rem;
            color: #334155;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sirraya Labs Header -->
        <div class="sirraya-header">
            <div class="sirraya-logo">
                <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="50" cy="50" r="45" stroke="#2563eb" stroke-width="2" fill="white"/>
                    <path d="M30 50 L45 65 L70 35" stroke="#2563eb" stroke-width="4" stroke-linecap="round" fill="none"/>
                    <circle cx="50" cy="50" r="8" fill="#2563eb"/>
                </svg>
                <div class="sirraya-title">
                    <h1>DID Key Recovery (DID-KR)</h1>
                    <div class="subtitle">Decentralized Identifier Key Recovery Extension</div>
                </div>
            </div>
            
            <div class="metadata">
                <div class="metadata-item">
                    <div class="label">Editor</div>
                    <div class="value">Amir Hameed Mir</div>
                </div>
                <div class="metadata-item">
                    <div class="label">Organization</div>
                    <div class="value">Sirraya Labs</div>
                </div>
                <div class="metadata-item">
                    <div class="label">Version</div>
                    <div class="value">1.0.0-draft</div>
                </div>
                <div class="metadata-item">
                    <div class="label">Repository</div>
                    <div class="value"><a href="https://github.com/sirraya-labs/did-kr">github.com/sirraya-labs/did-kr</a></div>
                </div>
            </div>
        </div>

        <!-- Abstract -->
        <section id="abstract">
            <h2>Abstract</h2>
            <p>
                This specification defines a standardized, interoperable mechanism for recovering control 
                of Decentralized Identifiers (DIDs) when private keys are lost or compromised. It introduces 
                three complementary recovery types—Social ZKP Recovery, Deterministic Seedling Inheritance, 
                and MPC-based Mediated Recovery—each addressing different trust models and user personas. 
                The specification includes cryptographic hardening through Verifiable Secret Sharing, 
                Verifiable Delay Functions, Proactive Secret Refreshment, and comprehensive security 
                considerations with a formal JSON-LD context for machine interoperability.
            </p>
        </section>

        <!-- Status -->
        <section id="sotd">
            <h2>Status of This Document</h2>
            <p>
                This is an Editor's Draft prepared by Amir Hameed Mir of Sirraya Labs. It is intended 
                for community review and implementation experimentation. Comments and contributions 
                are welcome via the GitHub repository.
            </p>
        </section>

        <!-- Introduction -->
        <section id="introduction">
            <h2>1. Introduction</h2>
            <p>
                The Decentralized Identifier (DID) architecture provides the foundation for self-sovereign 
                identity but deliberately omits key recovery mechanisms, leaving implementers to develop 
                ad-hoc, non-interoperable solutions. This gap represents a critical barrier to mass adoption, 
                as users face permanent loss of identity or vendor lock-in when keys are lost.
            </p>
            <p>
                The DID Key Recovery Extension (DID-KR) addresses this gap by defining standardized recovery 
                methods that can be published in DID Documents, discovered by resolvers, and executed through 
                interoperable protocols. The specification embraces a "three-way solution" recognizing that 
                no single recovery model suits all use cases:
            </p>
            <ul>
                <li><strong>Type A (Social ZKP Recovery):</strong> For users prioritizing autonomy, using threshold cryptography with zero-knowledge proofs to prevent guardian collusion.</li>
                <li><strong>Type B (Deterministic Seedling):</strong> For inheritance and migration, using hierarchical deterministic keys with Verifiable Delay Functions for decentralized time-locks.</li>
                <li><strong>Type C (MPC-Mediated):</strong> For enterprise and convenience users, using multi-party computation with threshold signatures and proactive share refreshment.</li>
            </ul>

            <h3>1.1 Design Goals</h3>
            <ul>
                <li><strong>Non-Custodial:</strong> No single entity ever possesses the full private key.</li>
                <li><strong>Interoperable:</strong> Recovery methods are discoverable and executable across different wallet implementations.</li>
                <li><strong>Privacy-Preserving:</strong> Recovery metadata minimizes leakage of social graphs and security posture.</li>
                <li><strong>Future-Proof:</strong> Cryptographic agility allows migration to quantum-resistant algorithms.</li>
            </ul>

            <h3>1.2 Relationship to DID Core</h3>
            <p>This specification extends DID Core by defining:</p>
            <ol>
                <li>A new <code>recovery</code> verification relationship.</li>
                <li>Three new verification method types for recovery.</li>
                <li>Service endpoint definitions for recovery protocols.</li>
                <li>A JSON-LD context for machine-readable discovery.</li>
            </ol>
        </section>

        <!-- Conformance -->
        <section id="conformance">
            <h2>2. Conformance</h2>
            <p>
                As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, 
                and notes in this specification are non-normative. Everything else in this specification is 
                normative.
            </p>
            <p>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", 
                "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted 
                as described in BCP 14 [[RFC2119]] [[RFC8174]] when, and only when, they appear in all capitals, 
                as shown here.
            </p>
        </section>

        <!-- Terminology -->
        <section id="terminology">
            <h2>3. Terminology</h2>
            <dl>
                <dt><dfn>DID Controller</dfn></dt>
                <dd>The entity authorized to make changes to a DID Document.</dd>
                
                <dt><dfn>Recovery Method</dfn></dt>
                <dd>A verification method specifically designated for recovering control of a DID.</dd>
                
                <dt><dfn>Guardian</dfn></dt>
                <dd>An entity holding a share of a recovery secret in Type A schemes.</dd>
                
                <dt><dfn>Beneficiary</dfn></dt>
                <dd>An entity authorized to inherit a DID in Type B schemes.</dd>
                
                <dt><dfn>Provider</dfn></dt>
                <dd>An MPC node participating in threshold signature generation for Type C schemes.</dd>
                
                <dt><dfn>Threshold (t)</dfn></dt>
                <dd>The minimum number of shares/participants required to complete recovery.</dd>
                
                <dt><dfn>Share Refreshment</dfn></dt>
                <dd>The process of generating new secret shares without changing the public key.</dd>
                
                <dt><dfn>Verifiable Delay Function (VDF)</dfn></dt>
                <dd>A function requiring a specific amount of sequential computation to evaluate.</dd>
                
                <dt><dfn>Epoch</dfn></dt>
                <dd>A version identifier for MPC provider share sets, incremented with each refreshment.</dd>
                
                <dt><dfn>Catch-up Protocol</dfn></dt>
                <dd>A mechanism for synchronizing lagging MPC providers to the current epoch.</dd>
            </dl>
        </section>

        <!-- Architecture -->
        <section id="architecture">
            <h2>4. The Recovery Method Architecture</h2>
            <p>
                The DID-KR architecture introduces a new verification relationship <code>recovery</code> in 
                the DID Document. This relationship contains one or more recovery methods that define how 
                a DID can be recovered.
            </p>

            <h3>4.1 Discovery Model</h3>
            <p>Recovery methods are discovered through standard DID resolution. A resolver or wallet implementing DID-KR:</p>
            <ol>
                <li>Resolves the DID Document.</li>
                <li>Checks for the <code>@context</code> including the DID-KR context.</li>
                <li>Extracts the <code>recovery</code> verification relationship.</li>
                <li>Parses the recovery methods according to their <code>type</code>.</li>
            </ol>

            <h3>4.2 Lifecycle</h3>
            <ol>
                <li><strong>Setup:</strong> The DID Controller generates recovery parameters and publishes them in the DID Document.</li>
                <li><strong>Execution:</strong> When recovery is needed, the recovering party initiates the protocol defined by the recovery method.</li>
                <li><strong>Completion:</strong> Upon successful recovery, the DID Document is updated with new verification methods, and the recovery methods may be rotated.</li>
                <li><strong>Revocation:</strong> Recovery methods can be revoked by the current controller using an active verification method.</li>
            </ol>
        </section>

        <!-- Recovery Method Types -->
        <section id="recovery-method-types">
            <h2>5. Recovery Method Types</h2>

            <!-- Type A -->
            <section id="type-a">
                <h3>5.1 Type A: Social ZKP Recovery</h3>
                <p><strong>Type URI:</strong> <code>RecoveryMethodZKPSocial</code></p>
                <p>
                    The Social ZKP Recovery mechanism enables recovery through a threshold of trusted guardians 
                    without revealing secret shares to any party, including the guardians themselves.
                </p>

                <h4>5.1.1 Cryptographic Requirements</h4>
                <p>Implementations MUST use:</p>
                <ul>
                    <li><strong>Verifiable Secret Sharing (VSS):</strong> Feldman's VSS with Pedersen commitments.</li>
                    <li><strong>Zero-Knowledge Proofs:</strong> Schnorr proofs of share consistency.</li>
                    <li><strong>Curve:</strong> Ed25519 or secp256k1 (with explicit specification).</li>
                </ul>

                <h4>5.1.2 Setup Phase</h4>
                <p>The DID Controller:</p>
                <ol>
                    <li>Generates a random secret <code>s</code> (the recovery key).</li>
                    <li>Constructs a random polynomial <code>P(x)</code> of degree <code>t-1</code> where <code>P(0) = s</code>.</li>
                    <li>Computes shares <code>si = P(i)</code> for each of <code>n</code> guardians.</li>
                    <li>Computes Pedersen commitments <code>Cj = g^{aj} * h^{bj}</code> for each coefficient <code>aj</code>.</li>
                    <li>Distributes to each guardian:
                        <ul>
                            <li>Their share <code>si</code> (encrypted to guardian's public key).</li>
                            <li>The commitments <code>Cj</code>.</li>
                            <li>A nonce for future ZKP challenges.</li>
                        </ul>
                    </li>
                    <li>Publishes in DID Document:
                        <ul>
                            <li>The commitments <code>Cj</code>.</li>
                            <li>Guardian identifiers and endpoints.</li>
                            <li>Threshold <code>t</code>.</li>
                        </ul>
                    </li>
                </ol>

                <h4>5.1.3 Recovery Phase</h4>
                <p>To recover:</p>
                <ol>
                    <li>Recovering party contacts <code>t</code> guardians.</li>
                    <li>Each guardian generates a ZKP proving:
                        <ul>
                            <li>Knowledge of share <code>si</code> consistent with commitments <code>Cj</code>.</li>
                            <li>Without revealing <code>si</code>.</li>
                        </ul>
                    </li>
                    <li>Guardians send ZKPs to recovering party or aggregation service.</li>
                    <li>ZKPs are verified and shares are reconstructed using Lagrange interpolation.</li>
                    <li>The reconstructed secret <code>s</code> is used to generate new DID keys.</li>
                </ol>

                <h4>5.1.4 DID Document Representation</h4>
                <pre>{
  "id": "did:example:123#recovery-social",
  "type": "RecoveryMethodZKPSocial",
  "controller": "did:example:123",
  "recoveryThreshold": 3,
  "recoveryGuardians": [
    {
      "id": "did:guardian:abc#key-1",
      "guardianEndpoint": "https://guardian1.example.com/recover",
      "guardianType": "person",
      "commitmentIndex": 0
    },
    {
      "id": "did:guardian:def#key-1",
      "guardianEndpoint": "https://guardian2.example.com/recover",
      "guardianType": "institution",
      "commitmentIndex": 1
    },
    {
      "id": "did:guardian:ghi#key-1",
      "guardianEndpoint": "https://guardian3.example.com/recover",
      "guardianType": "hardware",
      "commitmentIndex": 2
    }
  ],
  "vssCommitments": [
    "0x04a5...c3f2",
    "0x07b2...d1e4",
    "0x02c8...a9b6"
  ],
  "curve": "ed25519",
  "vssScheme": "feldman-2024"
}</pre>

                <div class="diagram-container">
                    <div class="diagram-title">Figure 1: Type A - Social ZKP Recovery Flow</div>
                    <div class="mermaid">
                        sequenceDiagram
                            participant User as User (Recovering Party)
                            participant G1 as Guardian 1
                            participant G2 as Guardian 2
                            participant G3 as Guardian 3
                            participant G4 as Guardian 4
                            participant G5 as Guardian 5
                            participant Aggregator as ZKP Aggregator
                            
                            Note over User: Initiates recovery (threshold=3)
                            
                            User->>G1: Request recovery (nonce, commitments)
                            User->>G2: Request recovery (nonce, commitments)
                            User->>G3: Request recovery (nonce, commitments)
                            
                            G1->>G1: Generate ZKP (share, commitments)
                            G2->>G2: Generate ZKP (share, commitments)
                            G3->>G3: Generate ZKP (share, commitments)
                            
                            G1-->>User: ZKP Proof 1
                            G2-->>User: ZKP Proof 2
                            G3-->>User: ZKP Proof 3
                            
                            User->>Aggregator: Submit proofs (threshold=3)
                            Aggregator->>Aggregator: Verify ZKPs
                            Aggregator->>Aggregator: Lagrange interpolation
                            
                            Aggregator-->>User: Recovered secret
                            User->>User: Generate new DID keys
                            User->>DID Method: Update DID Document
                    </div>
                </div>
            </section>

            <!-- Type B -->
            <section id="type-b">
                <h3>5.2 Type B: Deterministic Seedling Inheritance</h3>
                <p><strong>Type URI:</strong> <code>RecoveryMethodDeterministic</code></p>
                <p>
                    The Deterministic Seedling mechanism enables recovery through a master seed phrase, with 
                    optional time-locked inheritance for beneficiaries.
                </p>

                <h4>5.2.1 Cryptographic Requirements</h4>
                <p>Implementations MUST use:</p>
                <ul>
                    <li><strong>Hierarchical Deterministic Keys:</strong> BIP-32 or BIP-39 style derivation.</li>
                    <li><strong>Encryption:</strong> XChaCha20-Poly1305 for seed lockbox.</li>
                    <li><strong>Time-Locks:</strong> Verifiable Delay Functions (VDFs) for decentralized inheritance.</li>
                    <li><strong>VDF Algorithm:</strong> Wesolowski's VDF or Pietrzak's VDF.</li>
                </ul>

                <h4>5.2.2 Setup Phase</h4>
                <p>The DID Controller:</p>
                <ol>
                    <li>Generates a master seed <code>S</code> (128-256 bits of entropy).</li>
                    <li>Derives the DID private key using a standardized derivation path.</li>
                    <li>If inheritance desired:
                        <ul>
                            <li>Generates a VDF modulus <code>N</code> and challenge <code>x</code>.</li>
                            <li>Computes VDF output <code>y = x^(2^t) mod N</code>.</li>
                            <li>Uses <code>y</code> to derive encryption key for seed lockbox.</li>
                        </ul>
                    </li>
                    <li>Encrypts seed <code>S</code> to beneficiary's public key.</li>
                    <li>Publishes in DID Document:
                        <ul>
                            <li>Derivation path.</li>
                            <li>Encrypted seed lockbox.</li>
                            <li>VDF parameters (if inheritance enabled).</li>
                        </ul>
                    </li>
                </ol>

                <h4>5.2.3 Recovery Phase</h4>
                <p>For self-recovery:</p>
                <ol>
                    <li>User enters seed phrase.</li>
                    <li>Wallet re-derives keys using specified derivation path.</li>
                    <li>DID Document is updated with new keys.</li>
                </ol>
                <p>For inheritance:</p>
                <ol>
                    <li>Beneficiary waits for inactivity period.</li>
                    <li>Computes VDF for specified time parameter.</li>
                    <li>Derives decryption key from VDF output.</li>
                    <li>Decrypts seed lockbox.</li>
                    <li>Recovers DID using seed.</li>
                </ol>

                <h4>5.2.4 DID Document Representation</h4>
                <pre>{
  "id": "did:example:123#recovery-seedling",
  "type": "RecoveryMethodDeterministic",
  "controller": "did:example:123",
  "seedDerivationPath": "m/44'/0'/0'/0/0",
  "derivationStandard": "bip32-ed25519",
  "encryptedSeedLockbox": {
    "ciphertext": "0x7b3a...f9c2",
    "algorithm": "XChaCha20-Poly1305",
    "iv": "0x1a2b...3c4d",
    "beneficiaryPublicKey": "did:beneficiary:abc#key-1",
    "beneficiaryKeyType": "x25519"
  },
  "deadMansSwitch": {
    "type": "VDFTimeLock",
    "vdfParameters": {
      "difficulty": 1000000,
      "iterations": 10000,
      "estimatedWallTime": "P30D",
      "referencePlatform": "intel-i9-13900k-2024",
      "tolerance": 0.2,
      "modulus": "0x8f3b...a1c4",
      "challenge": "0x2d4e...f8a1",
      "vdfAlgorithm": "wesolowski-2024",
      "verificationMode": "wesolowski-optimistic"
    },
    "inactivityPeriod": "P1Y",
    "lastActivityProof": "https://notary.example.com/proof/123"
  }
}</pre>

                <div class="diagram-container">
                    <div class="diagram-title">Figure 2: Type B - VDF Time-Locked Inheritance</div>
                    <div class="mermaid">
                        sequenceDiagram
                            participant User as Original User
                            participant Beneficiary as Beneficiary
                            participant VDF as VDF Computation
                            participant Storage as Blockchain/Storage
                            participant DID as DID Method
                            
                            Note over User: Setup Phase
                            User->>User: Generate master seed
                            User->>User: Encrypt seed with VDF-derived key
                            User->>DID: Publish encrypted lockbox + VDF params
                            
                            Note over User: User becomes inactive
                            Note over Beneficiary: After P1Y, initiates inheritance
                            
                            Beneficiary->>VDF: Compute VDF (difficulty=1M)
                            VDF->>VDF: Sequential squaring (30 days)
                            VDF-->>Beneficiary: VDF output + proof
                            
                            Beneficiary->>Beneficiary: Derive decryption key from VDF output
                            Beneficiary->>Storage: Fetch encrypted lockbox
                            Beneficiary->>Beneficiary: Decrypt seed
                            Beneficiary->>Beneficiary: Derive DID keys
                            Beneficiary->>DID: Update DID Document with new controller
                    </div>
                </div>
            </section>

            <!-- Type C -->
            <section id="type-c">
                <h3>5.3 Type C: MPC-Mediated Recovery</h3>
                <p><strong>Type URI:</strong> <code>RecoveryMethodMPC</code></p>
                <p>
                    The MPC-Mediated Recovery mechanism distributes key shares across multiple independent 
                    providers who perform threshold signatures without reconstructing the full key.
                </p>

                <h4>5.3.1 Cryptographic Requirements</h4>
                <p>Implementations MUST use:</p>
                <ul>
                    <li><strong>Threshold Signatures:</strong> fROST (Flexible Round-Optimized Schnorr Threshold) signatures.</li>
                    <li><strong>Proactive Secret Sharing:</strong> Share refreshment protocol.</li>
                    <li><strong>Authentication:</strong> Verifiable Credentials or WebAuthn for user authentication to providers.</li>
                    <li><strong>Transport:</strong> mTLS or Noise Protocol for secure provider communication.</li>
                </ul>

                <h4>5.3.2 Setup Phase</h4>
                <p>The DID Controller:</p>
                <ol>
                    <li>Generates a threshold key pair with <code>t-of-n</code> providers.</li>
                    <li>Distributes shares to providers via secure channels.</li>
                    <li>Establishes authentication credentials with each provider.</li>
                    <li>Publishes in DID Document:
                        <ul>
                            <li>Provider endpoints.</li>
                            <li>Threshold parameters.</li>
                            <li>Share rotation schedule.</li>
                        </ul>
                    </li>
                </ol>

                <h4>5.3.3 Recovery Phase</h4>
                <p>To recover:</p>
                <ol>
                    <li>User authenticates to <code>t</code> providers using established credentials.</li>
                    <li>Providers verify user authentication and check for any revocation.</li>
                    <li>Providers engage in fROST signing protocol to generate a signature authorizing DID update.</li>
                    <li>The signature is used to create a new DID Document with fresh keys.</li>
                    <li>Providers optionally refresh their shares after successful recovery.</li>
                </ol>

                <h4>5.3.4 Share Refreshment</h4>
                <p>Providers MUST support periodic share refreshment:</p>
                <ol>
                    <li>At scheduled intervals, providers engage in refresh protocol.</li>
                    <li>New shares of the same secret are generated.</li>
                    <li>Old shares are securely deleted.</li>
                    <li>The public key remains unchanged.</li>
                </ol>

                <h4>5.3.5 DID Document Representation</h4>
                <pre>{
  "id": "did:example:123#recovery-mpc",
  "type": "RecoveryMethodMPC",
  "controller": "did:example:123",
  "mpcThreshold": 2,
  "mpcTotalProviders": 3,
  "mpcProtocol": "fROST-ed25519-2024",
  "mpcProviders": [
    {
      "id": "did:provider:one#mpc-node",
      "endpoint": "https://provider1.example.com/mpc",
      "authType": "vc-presentation",
      "authRequirements": {
        "credentialType": "MpcProviderCredential",
        "trustFramework": "did-kr-provider-v1"
      },
      "providerKey": "did:provider:one#key-1"
    },
    {
      "id": "did:provider:two#mpc-node",
      "endpoint": "https://provider2.example.com/mpc",
      "authType": "passkey",
      "authRequirements": {
        "rpId": "provider2.example.com",
        "algorithm": "es256"
      },
      "providerKey": "did:provider:two#key-1"
    },
    {
      "id": "did:provider:three#mpc-node",
      "endpoint": "https://provider3.example.com/mpc",
      "authType": "oauth2",
      "authRequirements": {
        "issuer": "https://auth.provider3.example.com",
        "scope": "did-recovery"
      },
      "providerKey": "did:provider:three#key-1"
    }
  ],
  "shareRotation": {
    "rotationInterval": "P30D",
    "currentEpoch": 42,
    "providerStateEndpoint": "https://provider1.example.com/state",
    "lastRotationProof": "0x8a3c...f2b5"
  }
}</pre>

                <div class="diagram-container">
                    <div class="diagram-title">Figure 3: Type C - MPC Recovery with Share Refreshment</div>
                    <div class="mermaid">
                        sequenceDiagram
                            participant User as User
                            participant P1 as Provider 1 (Epoch 42)
                            participant P2 as Provider 2 (Epoch 42)
                            participant P3 as Provider 3 (Epoch 41)
                            participant Coord as MPC Coordinator
                            
                            Note over User,P3: Recovery Initiated
                            
                            User->>P1: Authenticate (VC/Passkey)
                            User->>P2: Authenticate (VC/Passkey)
                            User->>P3: Authenticate (VC/Passkey)
                            
                            P1-->>User: Auth success (epoch=42)
                            P2-->>User: Auth success (epoch=42)
                            P3-->>User: Auth success (epoch=41)
                            
                            Note over User: Detects epoch skew
                            
                            User->>P3: Request catch-up
                            P3->>P1: Request refresh transcript (epochs 41→42)
                            P1-->>P3: Verifiable refresh proof
                            P3->>P3: Verify and update to epoch 42
                            P3-->>User: Ready (epoch=42)
                            
                            User->>Coord: Initiate MPC signing
                            Coord->>P1: Signing request (nonce)
                            Coord->>P2: Signing request (nonce)
                            Coord->>P3: Signing request (nonce)
                            
                            P1-->>Coord: Partial signature 1
                            P2-->>Coord: Partial signature 2
                            P3-->>Coord: Partial signature 3
                            
                            Coord->>Coord: Aggregate signatures (threshold=2)
                            Coord-->>User: Final signature
                            User->>DID Method: Update DID Document
                    </div>
                </div>
            </section>

            <!-- Provider State Synchronization -->
            <section id="provider-sync">
                <h3>5.4 Provider State Synchronization (Normative)</h3>
                <p>
                    When providers operate at different epochs, the recovery protocol MUST handle version skew 
                    to prevent state drift from becoming a single point of failure.
                </p>

                <h4>5.4.1 Epoch Discovery</h4>
                <p>
                    During recovery initiation, each provider MUST include their <code>currentEpoch</code> in 
                    the authentication response:
                </p>
                <pre>{
  "status": "authenticated",
  "provider": "did:provider:one#mpc-node",
  "currentEpoch": 42,
  "lastRotation": "2024-05-15T10:30:00Z",
  "signature": "0x9a8b..."
}</pre>

                <h4>5.4.2 Lag Detection</h4>
                <p>The recovering party (or coordinating provider) MUST compare epochs from all responding providers:</p>
                <ol>
                    <li>Determine the majority epoch (the epoch value held by the highest number of providers).</li>
                    <li>If any provider is more than <code>maxEpochSkew</code> behind the majority, that provider MUST be excluded from the signing ceremony.</li>
                    <li>The value of <code>maxEpochSkew</code> is defined in the DID Document and MUST NOT exceed 1 (RECOMMENDED) unless otherwise specified.</li>
                </ol>

                <h4>5.4.3 Automatic Catch-up Protocol</h4>
                <p>Providers lagging behind MUST have a mechanism to synchronize:</p>
                <ol>
                    <li>
                        <strong>Catch-up Request:</strong> The lagging provider sends a signed request to a quorum of up-to-date providers:
                        <pre>{
  "protocol": "catchup-request-v1",
  "provider": "did:provider:lagging#mpc-node",
  "currentEpoch": 41,
  "targetEpoch": 42,
  "signature": "0x7c3d..."
}</pre>
                    </li>
                    <li>
                        <strong>Verifiable Refresh Transcript:</strong> Up-to-date providers respond with:
                        <ul>
                            <li>The group's public key (unchanged across epochs).</li>
                            <li>A verifiable transcript of the refreshment protocol for epochs <code>current+1</code> through <code>target</code>.</li>
                            <li>Each transcript MUST include cryptographic proofs that the refreshment was performed correctly.</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Verification and Update:</strong> The lagging provider:
                        <ul>
                            <li>Verifies each transcript using the group's public key and published verification parameters.</li>
                            <li>Updates their local share to match the target epoch.</li>
                            <li>Securely deletes the old share.</li>
                        </ul>
                    </li>
                    <li><strong>Confirmation:</strong> Once updated, the provider confirms readiness to the recovering party.</li>
                </ol>

                <h4>5.4.4 DID Document Addition</h4>
                <p>The <code>shareRotation</code> object MUST include synchronization parameters:</p>
                <pre>"shareRotation": {
  "rotationInterval": "P30D",
  "currentEpoch": 42,
  "providerStateEndpoint": "https://provider1.example.com/state",
  "lastRotationProof": "0x8a3c...f2b5",
  "synchronization": {
    "maxEpochSkew": 1,
    "catchupProtocol": "vss-refresh-verifiable-2024",
    "timeout": "PT30S",
    "requiredQuorum": 2
  }
}</pre>
            </section>
        </section>

        <!-- Verification Relationships -->
        <section id="verification-relationships">
            <h2>6. Verification Relationships</h2>

            <h3>6.1 The <code>recovery</code> Relationship</h3>
            <p>
                The <code>recovery</code> verification relationship indicates that the associated verification 
                methods are specifically authorized for recovering control of the DID. These methods are not 
                intended for general authentication or assertion but are limited to recovery operations.
            </p>

            <pre>{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://sirraya.org/ns/did/recovery/v1"
  ],
  "id": "did:example:123",
  "recovery": [
    "did:example:123#recovery-social",
    "did:example:123#recovery-seedling",
    "did:example:123#recovery-mpc"
  ],
  "verificationMethod": [
    {
      "id": "did:example:123#recovery-social",
      "type": "RecoveryMethodZKPSocial",
      "controller": "did:example:123"
    }
  ]
}</pre>

            <h3>6.2 Processing Rules</h3>
            <p>When processing a recovery request:</p>
            <ol>
                <li>The resolver MUST verify that the recovery method is listed in the <code>recovery</code> relationship.</li>
                <li>The resolver MUST verify that the recovery method's <code>controller</code> is authorized to modify the DID Document.</li>
                <li>The resolver MUST perform dependency checking to prevent recovery loops.</li>
            </ol>
        </section>

        <!-- Cryptographic Primitives -->
        <section id="crypto-primitives">
            <h2>7. Cryptographic Primitives</h2>

            <h3>7.1 Verifiable Secret Sharing (Feldman's VSS)</h3>
            <p>Let <code>G</code> be a group of prime order <code>q</code> with generator <code>g</code>.</p>
            <ol>
                <li>Dealer chooses secret <code>s ∈ Z_q</code> and random polynomial <code>P(x) = s + a₁x + ... + aₜ₋₁x^(t-1)</code>.</li>
                <li>Dealer computes commitments <code>C₀ = g^s, C₁ = g^a₁, ..., Cₜ₋₁ = g^(aₜ₋₁)</code>.</li>
                <li>For participant <code>i</code>, share <code>sᵢ = P(i)</code> is sent securely.</li>
                <li>Participant verifies: <code>g^(sᵢ) = ∏(Cⱼ^(i^j)) for j=0 to t-1</code>.</li>
            </ol>

            <h3>7.2 Zero-Knowledge Proof of Share</h3>
            <p>To prove knowledge of share <code>sᵢ</code> without revealing it:</p>
            <ol>
                <li>Prover chooses random <code>r ← Z_q</code>.</li>
                <li>Prover sends <code>R = g^r</code>.</li>
                <li>Verifier sends challenge <code>c ← Z_q</code>.</li>
                <li>Prover sends <code>z = r + c·sᵢ mod q</code>.</li>
                <li>Verifier checks <code>g^z = R · (∏(Cⱼ^(i^j)))^c</code>.</li>
            </ol>

            <h3>7.3 Verifiable Delay Function (Wesolowski)</h3>
            <p>Input: <code>x ∈ QR(N)</code>, time parameter <code>T</code><br>
            Output: <code>y = x^(2^T) mod N</code>, proof <code>π</code></p>
            <ol>
                <li>Compute <code>y = x^(2^T) mod N</code> via sequential squaring.</li>
                <li>Let <code>l = ⌊2^T / 2⌋</code>, compute <code>π = x^l mod N</code>.</li>
                <li>Verifier checks: <code>π^(2^(T/2)) * x^(2^T mod 2^(T/2)) = y mod N</code>.</li>
            </ol>

            <h3>7.4 VDF Parameter Calibration (Normative)</h3>

            <h4>7.4.1 Difficulty Units</h4>
            <p>
                Difficulty is measured in <strong>sequential squaring operations</strong> estimated to require 
                a specific <strong>wall-clock time</strong> on a <strong>reference implementation</strong>.
            </p>

            <h4>7.4.2 Reference Platform Definition</h4>
            <ul>
                <li><strong>CPU:</strong> Intel i9-13900K (or equivalent), single-threaded execution</li>
                <li><strong>Memory:</strong> 32GB DDR5 RAM</li>
                <li><strong>Implementation:</strong> Optimized C with GMP library</li>
                <li><strong>Operating System:</strong> Linux kernel 6.1 or newer</li>
            </ul>

            <h4>7.4.3 Calibration Formula</h4>
            <p>The actual time required on a target platform is calculated as:</p>
            <pre>T_actual = T_reference × (Speed_reference / Speed_actual)</pre>

            <h4>7.4.4 Published Parameters</h4>
            <pre>"vdfParameters": {
  "difficulty": 1000000,
  "iterations": 10000,
  "estimatedWallTime": "P30D",
  "referencePlatform": "intel-i9-13900k-2024",
  "tolerance": 0.2,
  "verificationMode": "wesolowski-optimistic",
  "benchmarkRequired": false
}</pre>

            <h3>7.5 fROST Threshold Signatures</h3>
            <p>fROST enables <code>t-of-n</code> threshold Schnorr signatures:</p>
            <ol>
                <li><strong>Key Generation:</strong> Distributed key generation produces group public key and individual secret shares.</li>
                <li><strong>Signing:</strong> Each participant generates a nonce and commitment.</li>
                <li><strong>Aggregation:</strong> Coordinator aggregates commitments and challenges.</li>
                <li><strong>Response:</strong> Each participant responds with partial signatures.</li>
                <li><strong>Finalization:</strong> Coordinator aggregates partial signatures into final signature.</li>
            </ol>
        </section>

        <!-- Security Considerations -->
        <section id="security-considerations">
            <h2>8. Security Considerations</h2>

            <h3>8.1 Guardian Collusion (Type A)</h3>
            <p><strong>Threat:</strong> A threshold of guardians colludes to reconstruct the user's private key.</p>
            <p><strong>Mitigation:</strong> Verifiable Secret Sharing with Pedersen commitments ensures guardians cannot verify their shares are correct without the dealer's trapdoor. Additionally, guardians SHOULD be selected from diverse trust domains, and the threshold SHOULD be set high enough (e.g., 3-of-5) to make collusion difficult.</p>

            <h3>8.2 Time-Lock Bypass (Type B)</h3>
            <p><strong>Threat:</strong> An attacker compromises the dead man's switch to release inheritance keys prematurely.</p>
            <p><strong>Mitigation:</strong> Verifiable Delay Functions provide computational asymmetry—releasing the key requires a specific amount of sequential computation that cannot be parallelized. This prevents premature release even if the switch is compromised.</p>

            <h3>8.3 Provider State Drift (Type C)</h3>
            <p><strong>Threat:</strong> MPC providers update shares independently, causing key desynchronization.</p>
            <p><strong>Mitigation:</strong> Proactive Secret Sharing with verifiable refreshment protocols ensures all providers maintain consistent shares. The <code>shareRotation</code> object enables verification of current epoch, and the catch-up protocol ensures lagging providers can synchronize.</p>

            <h3>8.4 Recovery-Loop Prevention</h3>
            <p><strong>Threat:</strong> Circular recovery dependencies make recovery impossible.</p>
            <p><strong>Mitigation:</strong> Implementations MUST validate that the dependency graph of recovery methods is acyclic. This check MUST be performed when publishing a recovery method, when initiating recovery, and during periodic health checks.</p>
            
            <div class="algorithm">
                <pre>function checkAcyclic(did, visited = new Set()):
  if visited.has(did): return false
  visited.add(did)
  for each recoveryMethod in resolve(did).recovery:
    for each guardian in recoveryMethod.guardians:
      if guardian.did is DID:
        if not checkAcyclic(guardian.did, visited):
          return false
  visited.delete(did)
  return true</pre>
            </div>

            <div class="diagram-container">
                <div class="diagram-title">Figure 4: Recovery-Loop Prevention Check</div>
                <div class="mermaid">
                    graph TD
                        subgraph "Graph 1: Loop Detected"
                            A1[did:example:123] -->|recovery| B1[did:guardian:abc]
                            B1 -->|controller| A1
                        end
                        
                        subgraph "Graph 2: Valid Tree"
                            A2[did:example:123] -->|recovery| C2[did:guardian:def]
                            C2 -->|controller| D2[did:guardian:ghi]
                            D2 -->|controller| C2
                        end
                        
                        style A1 fill:#fee2e2,stroke:#ef4444,stroke-width:4px
                        style B1 fill:#fee2e2,stroke:#ef4444,stroke-width:2px
                        style A2 fill:#dcfce7,stroke:#22c55e,stroke-width:4px
                        style C2 fill:#dcfce7,stroke:#22c55e,stroke-width:2px
                        style D2 fill:#dcfce7,stroke:#22c55e,stroke-width:2px
                </div>
            </div>

            <h3>8.5 Key Wrapping Security</h3>
            <p><strong>Threat:</strong> Weak encryption of seed lockboxes.</p>
            <p><strong>Mitigation:</strong> All encrypted payloads MUST use authenticated encryption (AEAD) with 256-bit keys. The encryption algorithm MUST be explicitly specified, and implementations MUST reject algorithms known to be weak.</p>

            <h3>8.6 Quantum Computing Resistance</h3>
            <p>While current algorithms are secure against classical computers, implementations SHOULD plan for quantum resistance:</p>
            <ul>
                <li><strong>Type A:</strong> Consider lattice-based VSS for post-quantum security.</li>
                <li><strong>Type B:</strong> Use hash-based signatures for seed commitment.</li>
                <li><strong>Type C:</strong> Transition to threshold lattice signatures when standardized.</li>
            </ul>
        </section>

        <!-- Privacy Considerations -->
        <section id="privacy-considerations">
            <h2>9. Privacy Considerations</h2>

            <h3>9.1 Metadata Leakage</h3>
            <p>Recovery methods may leak:</p>
            <ul>
                <li>Social graph (guardian identities).</li>
                <li>Security posture (threshold values, provider choices).</li>
                <li>Activity patterns (last activity proofs).</li>
            </ul>
            <p><strong>Mitigations:</strong></p>
            <ol>
                <li><strong>Encrypted DID Document Entries:</strong> Recovery methods SHOULD be stored off-chain with only content-addressed references in the public DID Document.</li>
                <li><strong>Guardian Anonymity:</strong> Guardian endpoints SHOULD support onion services or other anonymizing networks.</li>
                <li><strong>Minimum Disclosure:</strong> Recovery methods SHOULD disclose only the minimum information needed for discovery.</li>
            </ol>

            <h3>9.2 Guardian Privacy (Enhanced)</h3>

            <h4>9.2.1 Hashed Guardian Identifiers (RECOMMENDED)</h4>
            <p>Instead of publishing full guardian DIDs, implementations SHOULD publish salted hashes:</p>
            <pre>"recoveryGuardians": [
  {
    "id": "urn:hash:sha256:3a7b...c9f2",
    "salt": "0x4d8e...f2a3",
    "guardianEndpoint": "http://guardian1.onion/recover",
    "commitmentIndex": 0
  }
]</pre>
            <p><strong>Resolution Protocol:</strong></p>
            <ol>
                <li>The recovering party knows the actual guardian DIDs.</li>
                <li>They compute hashes using the published salt and match against published values.</li>
                <li>The onion endpoint ensures guardian identity isn't leaked via DNS resolution.</li>
            </ol>

            <h4>9.2.2 Fully Encrypted Recovery Section (OPTIONAL)</h4>
            <p>For maximum privacy, the entire <code>recovery</code> verification relationship MAY be stored off-chain:</p>
            <pre>{
  "recovery": "ipfs://QmXyZ...abc123",
  "recoveryProof": "0x8a3c...f2b5"
}</pre>

            <h3>9.3 Correlation Risk</h3>
            <p>The same recovery method used across multiple DIDs could correlate them.</p>
            <p><strong>Mitigation:</strong> DID controllers SHOULD use different recovery methods for different DIDs, or ensure recovery methods are unlinkable through cryptographic techniques such as different salt values for each DID, different guardian sets, or unique encryption keys for each lockbox.</p>

            <h3>9.4 Beneficiary Privacy</h3>
            <p>In inheritance scenarios, the beneficiary's public key is published.</p>
            <p><strong>Mitigation:</strong> Beneficiaries SHOULD use single-use keys or derived addresses that cannot be linked to their primary identity. The <code>beneficiaryPublicKey</code> MAY be a derived key specific to this inheritance relationship.</p>
        </section>

        <!-- Interoperability -->
        <section id="interoperability">
            <h2>10. Interoperability Requirements</h2>

            <h3>10.1 Mandatory-to-Implement Algorithms</h3>
            <table>
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Usage</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>Ed25519</td><td>Signatures, VSS</td></tr>
                    <tr><td>SHA-256</td><td>Hashing</td></tr>
                    <tr><td>XChaCha20-Poly1305</td><td>Encryption</td></tr>
                    <tr><td>BIP-32</td><td>Key derivation</td></tr>
                    <tr><td>fROST (Ed25519)</td><td>Threshold signatures</td></tr>
                    <tr><td>Feldman VSS</td><td>Verifiable secret sharing</td></tr>
                    <tr><td>Wesolowski VDF</td><td>Time-locks</td></tr>
                </tbody>
            </table>

            <h3>10.2 Optional Algorithms</h3>
            <table>
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Usage</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>secp256k1</td><td>Blockchain compatibility</td></tr>
                    <tr><td>BLS12-381</td><td>Pairing-based cryptography</td></tr>
                    <tr><td>Pietrzak VDF</td><td>Time-locks</td></tr>
                    <tr><td>Dilithium</td><td>Post-quantum signatures</td></tr>
                    <tr><td>Kyber</td><td>Post-quantum encryption</td></tr>
                </tbody>
            </table>

            <h3>10.3 DID Method Compatibility</h3>
            <p>This specification is DID method agnostic but requires methods to support:</p>
            <ol>
                <li><strong>DID Document updates:</strong> The method must allow updating verification methods.</li>
                <li><strong>Resolution:</strong> The method must support resolving the DID Document to discover recovery methods.</li>
                <li><strong>Deactivation:</strong> The method should support deactivating compromised recovery methods.</li>
            </ol>
        </section>

        <!-- JSON-LD Context -->
        <section id="json-ld-context">
            <h2>11. JSON-LD Context</h2>
            <p>
                The complete JSON-LD context for this specification is available at:
                <code>https://sirraya.org/ns/did/recovery/v1.jsonld</code>
            </p>
            <pre>{
  "@context": {
    "@version": 1.1,
    "@protected": true,
    
    "id": "@id",
    "type": "@type",
    
    "RecoveryMethod": "https://sirraya.org/ns/did/recovery#RecoveryMethod",
    "RecoveryMethodZKPSocial": "https://sirraya.org/ns/did/recovery#RecoveryMethodZKPSocial",
    "RecoveryMethodDeterministic": "https://sirraya.org/ns/did/recovery#RecoveryMethodDeterministic",
    "RecoveryMethodMPC": "https://sirraya.org/ns/did/recovery#RecoveryMethodMPC",
    
    "recovery": {
      "@id": "https://sirraya.org/ns/did/recovery#recovery",
      "@type": "@id",
      "@container": "@set"
    },
    
    "recoveryThreshold": {
      "@id": "https://sirraya.org/ns/did/recovery#recoveryThreshold",
      "@type": "xsd:integer"
    },
    
    "recoveryGuardians": {
      "@id": "https://sirraya.org/ns/did/recovery#recoveryGuardians",
      "@type": "@id",
      "@container": "@set"
    },
    
    "guardianEndpoint": {
      "@id": "https://sirraya.org/ns/did/recovery#guardianEndpoint",
      "@type": "xsd:anyURI"
    },
    
    "vssCommitments": {
      "@id": "https://sirraya.org/ns/did/recovery#vssCommitments",
      "@type": "xsd:string",
      "@container": "@list"
    },
    
    "seedDerivationPath": {
      "@id": "https://sirraya.org/ns/did/recovery#seedDerivationPath",
      "@type": "xsd:string"
    },
    
    "encryptedSeedLockbox": {
      "@id": "https://sirraya.org/ns/did/recovery#encryptedSeedLockbox",
      "@type": "@id"
    },
    
    "deadMansSwitch": {
      "@id": "https://sirraya.org/ns/did/recovery#deadMansSwitch",
      "@type": "@id"
    },
    
    "vdfParameters": {
      "@id": "https://sirraya.org/ns/did/recovery#vdfParameters",
      "@type": "@id"
    },
    
    "mpcThreshold": {
      "@id": "https://sirraya.org/ns/did/recovery#mpcThreshold",
      "@type": "xsd:integer"
    },
    
    "mpcProviders": {
      "@id": "https://sirraya.org/ns/did/recovery#mpcProviders",
      "@type": "@id",
      "@container": "@set"
    },
    
    "shareRotation": {
      "@id": "https://sirraya.org/ns/did/recovery#shareRotation",
      "@type": "@id"
    },
    
    "currentEpoch": {
      "@id": "https://sirraya.org/ns/did/recovery#currentEpoch",
      "@type": "xsd:integer"
    },
    
    "synchronization": {
      "@id": "https://sirraya.org/ns/did/recovery#synchronization",
      "@type": "@id"
    },
    
    "maxEpochSkew": {
      "@id": "https://sirraya.org/ns/did/recovery#maxEpochSkew",
      "@type": "xsd:integer"
    },
    
    "catchupProtocol": {
      "@id": "https://sirraya.org/ns/did/recovery#catchupProtocol",
      "@type": "xsd:string"
    }
  }
}</pre>
        </section>

        <!-- Protocol Flows -->
        <section id="protocol-flows">
            <h2>12. Recovery Protocol Flows</h2>

            <h3>12.1 Type A Recovery Protocol</h3>
            <p><strong>Endpoint:</strong> Guardian-provided <code>guardianEndpoint</code></p>
            <p><strong>Request:</strong></p>
            <pre>POST /recover HTTP/1.1
Host: guardian1.example.com
Content-Type: application/json

{
  "protocol": "did-kr-recovery-v1",
  "recoveryId": "did:example:123#recovery-social",
  "did": "did:example:123",
  "nonce": "a1b2c3d4e5f6...",
  "challenge": "0x4d5e6f7a8b9c...",
  "commitmentIndex": 0
}</pre>
            <p><strong>Response:</strong></p>
            <pre>{
  "status": "success",
  "proof": {
    "type": "schnorr-proof-2024",
    "commitment": "0x8f3a2b1c...",
    "challenge": "0x4d5e6f7a...",
    "response": "0x2b7c8d9e..."
  },
  "guardianId": "did:guardian:abc#key-1",
  "signature": "0x9a8b7c6d..."
}</pre>

            <h3>12.2 Type B Recovery Protocol</h3>
            <p><strong>For self-recovery:</strong></p>
            <pre>POST /recover/seed HTTP/1.1
Host: wallet.example.com
Content-Type: application/json

{
  "protocol": "did-kr-recovery-v1",
  "recoveryId": "did:example:123#recovery-seedling",
  "seedPhrase": "abandon ability able about above absent absorb abstract absurd abuse access accident account accuse achieve acid acoustic acquire across act action actor actress actual adapt add",
  "derivationPath": "m/44'/0'/0'/0/0"
}</pre>
            <p><strong>For inheritance:</strong></p>
            <pre>POST /recover/inherit HTTP/1.1
Host: beneficiary.example.com
Content-Type: application/json

{
  "protocol": "did-kr-recovery-v1",
  "recoveryId": "did:example:123#recovery-seedling",
  "vdfProof": {
    "output": "0x7c3d4e5f...",
    "proof": "0x2a5b6c7d...",
    "computationTime": "P32D",
    "platform": "amd-ryzen-7950x-2025"
  }
}</pre>

            <h3>12.3 Type C Recovery Protocol</h3>
            <p><strong>Phase 1: Authentication</strong></p>
            <pre>POST /mpc/auth HTTP/1.1
Host: provider1.example.com
Content-Type: application/json

{
  "protocol": "did-kr-recovery-v1",
  "recoveryId": "did:example:123#recovery-mpc",
  "authType": "vc-presentation",
  "presentation": {
    "@context": "https://www.w3.org/2018/credentials/v1",
    "type": ["VerifiablePresentation"],
    "verifiableCredential": [...]
  }
}</pre>
            <p><strong>Authentication Response:</strong></p>
            <pre>{
  "status": "authenticated",
  "provider": "did:provider:one#mpc-node",
  "currentEpoch": 42,
  "lastRotation": "2024-05-15T10:30:00Z",
  "signature": "0x9a8b7c6d..."
}</pre>
            <p><strong>Phase 2: MPC Signing Ceremony</strong></p>
            <pre>POST /mpc/sign HTTP/1.1
Host: provider1.example.com
Content-Type: application/json

{
  "protocol": "did-kr-recovery-v1",
  "sessionId": "sess_abc123def456",
  "operation": {
    "type": "update-did",
    "newDocument": {
      "id": "did:example:123",
      "verificationMethod": [
        {
          "id": "did:example:123#new-key-1",
          "type": "Ed25519VerificationKey2020",
          "controller": "did:example:123",
          "publicKeyMultibase": "z6Mkq3..."
        }
      ],
      "authentication": ["did:example:123#new-key-1"]
    }
  },
  "commitment": "0x3e4f5a6b..."
}</pre>
        </section>

        <!-- Test Vectors -->
        <section id="test-vectors">
            <h2>13. Test Vectors</h2>

            <h3>13.1 Type A Test Vector</h3>
            <p><strong>Setup:</strong></p>
            <ul>
                <li>Secret: <code>s = 42</code></li>
                <li>Threshold: <code>t = 3</code></li>
                <li>Guardians: <code>n = 5</code></li>
                <li>Curve: Ed25519</li>
                <li>Prime: <code>2^252 + 27742317777372353535851937790883648493</code></li>
            </ul>
            <p><strong>Polynomial:</strong> <code>P(x) = 42 + 17x + 8x²</code></p>
            <p><strong>Shares:</strong> <code>s₁ = 67, s₂ = 104, s₃ = 153, s₄ = 214, s₅ = 287</code></p>
            <p><strong>Recovery with shares s₁, s₃, s₅:</strong> <code>42</code></p>

            <h3>13.2 Type B Test Vector</h3>
            <p><strong>Master Seed:</strong> <code>0x7f3a9b8c2d5e1f4a3b6c7d8e9f0a1b2c</code></p>
            <p><strong>Derivation Path:</strong> <code>m/44'/0'/0'/0/0</code></p>
            <p><strong>Derived Private Key:</strong> <code>0x9d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a</code></p>

            <h3>13.3 Type C Test Vector</h3>
            <p><strong>fROST with t=2, n=3:</strong></p>
            <pre>Group Public Key: 0x3a7b8c9d0e1f2a3b4c5d6e7f8a9b0c
Share 1: 0x8c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0
Share 2: 0x2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c
Share 3: 0x7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a</pre>
        </section>

        <!-- References -->
        <section id="references">
            <h2>14. References</h2>

            <h3>14.1 Normative References</h3>
            <dl>
                <dt>[[DID-CORE]]</dt>
                <dd>Decentralized Identifier Specification v1.0</dd>
                <dt>[[RFC2119]]</dt>
                <dd>Key words for use in RFCs</dd>
                <dt>[[RFC8174]]</dt>
                <dd>Ambiguity of Uppercase vs Lowercase in RFC2119</dd>
                <dt>[[BIP32]]</dt>
                <dd>Hierarchical Deterministic Wallets</dd>
                <dt>[[BIP39]]</dt>
                <dd>Mnemonic code for generating deterministic keys</dd>
                <dt>[[FROST]]</dt>
                <dd>Flexible Round-Optimized Schnorr Threshold Signatures</dd>
                <dt>[[VDF]]</dt>
                <dd>Verifiable Delay Functions</dd>
                <dt>[[FELDMAN]]</dt>
                <dd>Feldman's Verifiable Secret Sharing</dd>
            </dl>

            <h3>14.2 Informative References</h3>
            <dl>
                <dt>[[SOCIAL-RECOVERY]]</dt>
                <dd>Social Key Recovery for Self-Sovereign Identity</dd>
                <dt>[[MPC-WALLET]]</dt>
                <dd>Threshold Signatures for Cryptographic Wallets</dd>
                <dt>[[TIME-LOCK]]</dt>
                <dd>Time-Lock Encryption with Verifiable Delay Functions</dd>
                <dt>[[ZKP-AUTH]]</dt>
                <dd>Zero-Knowledge Proofs for Authentication</dd>
                <dt>[[PROACTIVE]]</dt>
                <dd>Proactive Secret Sharing</dd>
            </dl>
        </section>

        <!-- Acknowledgements -->
        <section id="acknowledgements">
            <h2>15. Acknowledgements</h2>
            <p>
                The editor would like to thank the members of the decentralized identity community for their 
                valuable feedback and contributions. Special thanks to the cryptographic reviewers who provided 
                security analysis of the VSS, VDF, and fROST implementations, and to the privacy researchers 
                who contributed to the guardian privacy enhancements.
            </p>
        </section>

        <!-- Appendices -->
        <section id="appendices">
            <h2>Appendices</h2>

            <h3>Appendix A: Implementation Checklist</h3>
            <table>
                <thead>
                    <tr>
                        <th>Requirement</th>
                        <th>Status</th>
                        <th>Notes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>Type A: VSS implementation</td><td>☐</td><td>Feldman's VSS with Pedersen</td></tr>
                    <tr><td>Type A: ZKP implementation</td><td>☐</td><td>Schnorr proofs of share</td></tr>
                    <tr><td>Type A: Guardian privacy</td><td>☐</td><td>Hashed identifiers</td></tr>
                    <tr><td>Type B: HD key derivation</td><td>☐</td><td>BIP-32 compatible</td></tr>
                    <tr><td>Type B: VDF implementation</td><td>☐</td><td>Wesolowski or Pietrzak</td></tr>
                    <tr><td>Type B: VDF calibration</td><td>☐</td><td>Hardware-agnostic parameters</td></tr>
                    <tr><td>Type C: fROST implementation</td><td>☐</td><td>Threshold signatures</td></tr>
                    <tr><td>Type C: Share refreshment</td><td>☐</td><td>Proactive secret sharing</td></tr>
                    <tr><td>Type C: Epoch synchronization</td><td>☐</td><td>Catch-up protocol</td></tr>
                    <tr><td>Recovery-loop detection</td><td>☐</td><td>Graph acyclicity check</td></tr>
                    <tr><td>JSON-LD context</td><td>☐</td><td>Published at specified URL</td></tr>
                    <tr><td>Test vectors</td><td>☐</td><td>All types validated</td></tr>
                    <tr><td>Security review</td><td>☐</td><td>External audit</td></tr>
                    <tr><td>Privacy review</td><td>☐</td><td>Social graph analysis</td></tr>
                </tbody>
            </table>

            
        </section>

        <!-- Footer -->
        <div class="footer">
            <p>© 2026 Sirraya Labs. This document is licensed under the MIT License, Version 2.0.</p>
            <p>Editor: Amir Hameed Mir · <a href="mailto:amir@sirraya.org">amir@sirraya.org</a></p>
            <p><a href="https://github.com/sirraya-labs/did-kr">GitHub Repository</a> · <a href="https://sirraya.org">sirraya.org</a></p>
        </div>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({
            startOnLoad: true,
            theme: 'neutral',
            flowchart: {
                useMaxWidth: false,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                showSequenceNumbers: false,
                actorMargin: 50,
                height: 50
            }
        });

        // Initialize syntax highlighting
        hljs.highlightAll();
    </script>
</body>
</html>