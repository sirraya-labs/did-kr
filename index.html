<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DID Key Recovery Specification (DID-KR) · Sirraya Labs</title>
    
    <!-- Mermaid for diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    
    <!-- Syntax highlighting for code blocks -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.7;
            color: #1a2b3c;
            background: #f8fafc;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background: white;
            box-shadow: 0 20px 40px rgba(0,0,0,0.05);
        }
        
        /* Sirraya Labs header */
        .sirraya-header {
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 2px solid #e9ecef;
        }
        
        .sirraya-logo {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .sirraya-logo svg {
            width: 50px;
            height: 50px;
        }
        
        .sirraya-title h1 {
            font-size: 2.5rem;
            font-weight: 600;
            background: linear-gradient(135deg, #2563eb, #7c3aed);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }
        
        .sirraya-title .subtitle {
            font-size: 1.2rem;
            color: #64748b;
        }
        
        .metadata {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            background: #f1f5f9;
            padding: 1.5rem;
            border-radius: 12px;
            margin: 2rem 0;
        }
        
        .metadata-item {
            flex: 1;
            min-width: 200px;
        }
        
        .metadata-item .label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #64748b;
            margin-bottom: 0.25rem;
        }
        
        .metadata-item .value {
            font-size: 1.1rem;
            font-weight: 500;
            color: #0f172a;
        }

        /* Revision banner */
        .revision-banner {
            background: #f0fdf4;
            border: 1px solid #86efac;
            border-left: 4px solid #22c55e;
            border-radius: 0 12px 12px 0;
            padding: 1.5rem;
            margin: 1.5rem 0 2rem;
        }

        .revision-banner .banner-title {
            font-weight: 700;
            color: #15803d;
            font-size: 1rem;
            margin-bottom: 0.5rem;
        }

        .revision-banner ul {
            margin: 0.5rem 0 0 1.25rem;
            color: #166534;
        }

        .revision-banner li {
            margin-bottom: 0.3rem;
            font-size: 0.95rem;
        }
        
        /* Typography */
        h2 {
            font-size: 2rem;
            font-weight: 600;
            color: #0f172a;
            margin: 3rem 0 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 3px solid #e2e8f0;
        }
        
        h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1e293b;
            margin: 2rem 0 1rem;
        }
        
        h4 {
            font-size: 1.25rem;
            font-weight: 500;
            color: #334155;
            margin: 1.5rem 0 0.75rem;
        }
        
        p {
            margin-bottom: 1.25rem;
            color: #334155;
        }
        
        ul, ol {
            margin: 1rem 0 1.5rem 1.5rem;
            color: #334155;
        }
        
        li {
            margin-bottom: 0.5rem;
        }
        
        a {
            color: #2563eb;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        /* Code blocks */
        pre {
            background: #0f172a;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 12px;
            overflow-x: auto;
            font-family: 'Fira Code', 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            margin: 1.5rem 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        code {
            font-family: 'Fira Code', 'JetBrains Mono', monospace;
            background: #f1f5f9;
            color: #0f172a;
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        pre code {
            background: transparent;
            color: inherit;
            padding: 0;
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        
        th {
            background: #1e293b;
            color: white;
            font-weight: 600;
            padding: 1rem;
            text-align: left;
        }
        
        td {
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
        }
        
        tr:last-child td {
            border-bottom: none;
        }
        
        tr:hover td {
            background: #f8fafc;
        }
        
        /* Diagrams */
        .diagram-container {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 8px 16px rgba(0,0,0,0.05);
        }
        
        .diagram-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #0f172a;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .mermaid {
            background: white;
            text-align: center;
        }
        
        /* Notes and callouts */
        .note {
            background: #fef9c3;
            border-left: 4px solid #eab308;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 12px 12px 0;
        }

        .note strong { color: #92400e; }
        
        .warning {
            background: #fee2e2;
            border-left: 4px solid #ef4444;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 12px 12px 0;
        }

        .info {
            background: #eff6ff;
            border-left: 4px solid #3b82f6;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 12px 12px 0;
        }

        .info strong { color: #1d4ed8; }

        .corrected {
            background: #f0fdf4;
            border-left: 4px solid #22c55e;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 12px 12px 0;
        }

        .corrected strong { color: #15803d; }
        
        .algorithm {
            background: #f1f5f9;
            padding: 1.5rem;
            border-radius: 12px;
            font-family: 'Fira Code', monospace;
            border: 1px solid #cbd5e1;
            margin: 1.5rem 0;
        }

        /* Math display blocks */
        .math-block {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 1.25rem 1.5rem;
            font-family: 'Fira Code', 'JetBrains Mono', monospace;
            font-size: 0.92rem;
            line-height: 2;
            margin: 1.25rem 0 1.75rem;
            color: #1e293b;
        }

        .math-block .comment {
            color: #94a3b8;
            font-style: italic;
        }

        /* Parameter display */
        .param-table {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 1.25rem 1.5rem;
            font-family: 'Fira Code', monospace;
            font-size: 0.88rem;
            line-height: 1.9;
            margin: 1.25rem 0 1.75rem;
        }

        .param-table .row { display: flex; gap: 1rem; flex-wrap: wrap; }
        .param-table .key { color: #2563eb; font-weight: 600; min-width: 50px; }
        .param-table .val { color: #1e293b; word-break: break-all; }

        /* Tag badges */
        .tag {
            display: inline-block;
            font-size: 0.7rem;
            font-family: 'Fira Code', monospace;
            padding: 0.15em 0.55em;
            border-radius: 4px;
            vertical-align: middle;
            font-weight: 600;
            letter-spacing: 0.03em;
            margin-left: 0.4rem;
        }

        .tag-new { background: #dcfce7; color: #15803d; border: 1px solid #86efac; }
        .tag-updated { background: #dbeafe; color: #1d4ed8; border: 1px solid #93c5fd; }
        .tag-fixed { background: #fef3c7; color: #92400e; border: 1px solid #fcd34d; }

        /* Status badges in tables */
        .status-done { color: #15803d; font-weight: 700; }
        .status-open { color: #64748b; }
        
        /* Footer */
        .footer {
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 2px solid #e2e8f0;
            text-align: center;
            color: #64748b;
            font-size: 0.9rem;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .container { padding: 1rem; }
            .metadata { flex-direction: column; gap: 1rem; }
            h1 { font-size: 2rem; }
        }

        .example {
            background: #0f172a;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 12px;
            overflow-x: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            margin: 1.5rem 0;
        }

        dt {
            font-weight: 600;
            color: #0f172a;
            margin-top: 1rem;
        }

        dd {
            margin-left: 1.5rem;
            margin-bottom: 0.5rem;
            color: #334155;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sirraya Labs Header -->
        <div class="sirraya-header">
            <div class="sirraya-logo">
                <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="50" cy="50" r="45" stroke="#2563eb" stroke-width="2" fill="white"/>
                    <path d="M30 50 L45 65 L70 35" stroke="#2563eb" stroke-width="4" stroke-linecap="round" fill="none"/>
                    <circle cx="50" cy="50" r="8" fill="#2563eb"/>
                </svg>
                <div class="sirraya-title">
                    <h1>DID Key Recovery (DID-KR)</h1>
                    <div class="subtitle">Decentralized Identifier Key Recovery Extension</div>
                </div>
            </div>
            
            <div class="metadata">
                <div class="metadata-item">
                    <div class="label">Editor</div>
                    <div class="value">Amir Hameed Mir</div>
                </div>
                <div class="metadata-item">
                    <div class="label">Organization</div>
                    <div class="value">Sirraya Labs</div>
                </div>
                <div class="metadata-item">
                    <div class="label">Version</div>
                    <div class="value">1.0.0-draft · rev 2.1</div>
                </div>
                <div class="metadata-item">
                    <div class="label">Repository</div>
                    <div class="value"><a href="https://github.com/sirraya-labs/did-kr">github.com/sirraya-labs/did-kr</a></div>
                </div>
            </div>

            <div class="revision-banner">
                <div class="banner-title">Revision 2.1 — VSS Implementation Corrected</div>
                <ul>
                    <li><strong>§7.0 (new):</strong> Defines mandatory VSS group parameters — 256-bit safe prime <em>p = 2q+1</em>, replacing the  secp256k1-reuse pattern from rev 1.x.</li>
                    <li><strong>§7.1 (updated):</strong> Feldman VSS now uses separate scalar field Z<sub>q</sub> for polynomial arithmetic and group Z<sub>p</sub>* for commitments, with <em>ord(g) = q</em>. Verification equation corrected.</li>
                    <li><strong>§7.1.3 (new):</strong> Proactive Share Refreshment specified normatively, including combined commitment update equation.</li>
                    <li><strong>§13 (updated):</strong> All Type A test vectors replaced with mathematically correct values computed over (p, q, g). Refresh vector added.</li>
                    <li><strong>Appendix A (updated):</strong> VSS generation/verification and proactive refresh marked complete. New open items: ephemeral key persistence, API authentication, social recovery path.</li>
                </ul>
            </div>
        </div>

        <!-- Abstract -->
        <section id="abstract">
            <h2>Abstract</h2>
            <p>
                This specification defines a standardized, interoperable mechanism for recovering control 
                of Decentralized Identifiers (DIDs) when private keys are lost or compromised. It introduces 
                three complementary recovery types — Social ZKP Recovery, Deterministic Seedling Inheritance, 
                and MPC-based Mediated Recovery — each addressing different trust models and user personas. 
                The specification includes cryptographic hardening through mathematically correct Verifiable 
                Secret Sharing (Feldman VSS over a proper prime-order group), Verifiable Delay Functions, 
                Proactive Secret Refreshment, and comprehensive security considerations with a formal 
                JSON-LD context for machine interoperability.
            </p>
        </section>

        <!-- Status -->
        <section id="sotd">
            <h2>Status of This Document</h2>
            <p>
                This is an Editor's Draft prepared by Amir Hameed Mir of Sirraya Labs. Revision 2.1 
                corrects a critical mathematical error in the Feldman VSS specification and the corresponding 
                reference implementation (see §7.0 and §7.1). Comments and contributions are welcome 
                via the GitHub repository.
            </p>
        </section>

        <!-- Introduction -->
        <section id="introduction">
            <h2>1. Introduction</h2>
            <p>
                The Decentralized Identifier (DID) architecture provides the foundation for self-sovereign 
                identity but deliberately omits key recovery mechanisms, leaving implementers to develop 
                ad-hoc, non-interoperable solutions. This gap represents a critical barrier to mass adoption, 
                as users face permanent loss of identity or vendor lock-in when keys are lost.
            </p>
            <p>
                The DID Key Recovery Extension (DID-KR) addresses this gap by defining standardized recovery 
                methods that can be published in DID Documents, discovered by resolvers, and executed through 
                interoperable protocols. The specification embraces a "three-way solution" recognizing that 
                no single recovery model suits all use cases:
            </p>
            <ul>
                <li><strong>Type A (Social ZKP Recovery):</strong> For users prioritizing autonomy, using threshold cryptography with zero-knowledge proofs to prevent guardian collusion.</li>
                <li><strong>Type B (Deterministic Seedling):</strong> For inheritance and migration, using hierarchical deterministic keys with Verifiable Delay Functions for decentralized time-locks.</li>
                <li><strong>Type C (MPC-Mediated):</strong> For enterprise and convenience users, using multi-party computation with threshold signatures and proactive share refreshment.</li>
            </ul>

            <h3>1.1 Design Goals</h3>
            <ul>
                <li><strong>Non-Custodial:</strong> No single entity ever possesses the full private key.</li>
                <li><strong>Interoperable:</strong> Recovery methods are discoverable and executable across different wallet implementations.</li>
                <li><strong>Privacy-Preserving:</strong> Recovery metadata minimizes leakage of social graphs and security posture.</li>
                <li><strong>Mathematically Sound:</strong> All cryptographic constructions use correctly parameterized groups with proven security properties.</li>
                <li><strong>Future-Proof:</strong> Cryptographic agility allows migration to quantum-resistant algorithms.</li>
            </ul>

            <h3>1.2 Relationship to DID Core</h3>
            <p>This specification extends DID Core by defining:</p>
            <ol>
                <li>A new <code>recovery</code> verification relationship.</li>
                <li>Three new verification method types for recovery.</li>
                <li>Service endpoint definitions for recovery protocols.</li>
                <li>A JSON-LD context for machine-readable discovery.</li>
            </ol>
        </section>

        <!-- Conformance -->
        <section id="conformance">
            <h2>2. Conformance</h2>
            <p>
                As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, 
                and notes in this specification are non-normative. Everything else in this specification is 
                normative.
            </p>
            <p>
                The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", 
                "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted 
                as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, 
                as shown here.
            </p>
        </section>

        <!-- Terminology -->
        <section id="terminology">
            <h2>3. Terminology</h2>
            <dl>
                <dt><dfn>DID Controller</dfn></dt>
                <dd>The entity authorized to make changes to a DID Document.</dd>
                
                <dt><dfn>Recovery Method</dfn></dt>
                <dd>A verification method specifically designated for recovering control of a DID.</dd>
                
                <dt><dfn>Guardian</dfn></dt>
                <dd>An entity holding a share of a recovery secret in Type A schemes.</dd>
                
                <dt><dfn>Beneficiary</dfn></dt>
                <dd>An entity authorized to inherit a DID in Type B schemes.</dd>
                
                <dt><dfn>Provider</dfn></dt>
                <dd>An MPC node participating in threshold signature generation for Type C schemes.</dd>
                
                <dt><dfn>Threshold (t)</dfn></dt>
                <dd>The minimum number of shares/participants required to complete recovery.</dd>

                <dt><dfn>Scalar Field Z<sub>q</sub></dfn></dt>
                <dd>A prime field of order q used for polynomial arithmetic in VSS. All share values, polynomial coefficients, and Lagrange interpolation operate in Z<sub>q</sub>.</dd>

                <dt><dfn>Commitment Group Z<sub>p</sub>*</dfn></dt>
                <dd>The multiplicative group modulo a prime p used for Feldman commitments. Distinct from the scalar field; chosen so that q divides (p−1), guaranteeing a subgroup of prime order q.</dd>

                <dt><dfn>Safe Prime</dfn></dt>
                <dd>A prime p such that p = 2q+1 where q is also prime. Guarantees a subgroup of prime order q in Z<sub>p</sub>*.</dd>
                
                <dt><dfn>Share Refreshment</dfn></dt>
                <dd>The process of generating new secret shares without changing the secret or public commitments, by adding shares of a zero-secret refresh polynomial.</dd>
                
                <dt><dfn>Verifiable Delay Function (VDF)</dfn></dt>
                <dd>A function requiring a specific amount of sequential computation to evaluate.</dd>
                
                <dt><dfn>Epoch</dfn></dt>
                <dd>A version identifier for MPC provider share sets, incremented with each refreshment.</dd>
                
                <dt><dfn>Catch-up Protocol</dfn></dt>
                <dd>A mechanism for synchronizing lagging MPC providers to the current epoch.</dd>
            </dl>
        </section>

        <!-- Architecture -->
        <section id="architecture">
            <h2>4. The Recovery Method Architecture</h2>
            <p>
                The DID-KR architecture introduces a new verification relationship <code>recovery</code> in 
                the DID Document. This relationship contains one or more recovery methods that define how 
                a DID can be recovered.
            </p>

            <h3>4.1 Discovery Model</h3>
            <p>Recovery methods are discovered through standard DID resolution. A resolver or wallet implementing DID-KR:</p>
            <ol>
                <li>Resolves the DID Document.</li>
                <li>Checks for the <code>@context</code> including the DID-KR context.</li>
                <li>Extracts the <code>recovery</code> verification relationship.</li>
                <li>Parses the recovery methods according to their <code>type</code>.</li>
            </ol>

            <h3>4.2 Lifecycle</h3>
            <ol>
                <li><strong>Setup:</strong> The DID Controller generates recovery parameters and publishes them in the DID Document.</li>
                <li><strong>Execution:</strong> When recovery is needed, the recovering party initiates the protocol defined by the recovery method.</li>
                <li><strong>Completion:</strong> Upon successful recovery, the DID Document is updated with new verification methods, and the recovery methods may be rotated.</li>
                <li><strong>Revocation:</strong> Recovery methods can be revoked by the current controller using an active verification method.</li>
            </ol>
        </section>

        <!-- Recovery Method Types -->
        <section id="recovery-method-types">
            <h2>5. Recovery Method Types</h2>

            <!-- Type A -->
            <section id="type-a">
                <h3>5.1 Type A: Social ZKP Recovery</h3>
                <p><strong>Type URI:</strong> <code>RecoveryMethodZKPSocial</code></p>
                <p>
                    The Social ZKP Recovery mechanism enables recovery through a threshold of trusted guardians 
                    without revealing secret shares to any party, including the guardians themselves.
                </p>

                <h4>5.1.1 Cryptographic Requirements</h4>
                <p>Implementations MUST use:</p>
                <ul>
                    <li><strong>Verifiable Secret Sharing (VSS):</strong> Feldman's VSS as specified in §7.1, using the group parameters defined in §7.0.</li>
                    <li><strong>Zero-Knowledge Proofs:</strong> Schnorr proofs of share consistency as specified in §7.2.</li>
                    <li><strong>Group:</strong> The 256-bit safe-prime group (p, q, g) defined in §7.0.</li>
                </ul>

                <h4>5.1.2 Setup Phase</h4>
                <p>The DID Controller:</p>
                <ol>
                    <li>Generates a random secret <code>s ∈ Z<sub>q</sub></code> (the recovery key).</li>
                    <li>Constructs a random polynomial <code>P(x)</code> of degree <code>t−1</code> over <code>Z<sub>q</sub></code> where <code>P(0) = s</code>.</li>
                    <li>Computes shares <code>s<sub>i</sub> = P(i) mod q</code> for each of <code>n</code> guardians.</li>
                    <li>Computes Feldman commitments <code>C<sub>j</sub> = g<sup>a<sub>j</sub></sup> mod p</code> for each polynomial coefficient <code>a<sub>j</sub></code>.</li>
                    <li>Distributes to each guardian:
                        <ul>
                            <li>Their encrypted share <code>s<sub>i</sub></code>.</li>
                            <li>The commitments <code>C<sub>j</sub></code>.</li>
                            <li>A nonce for ZKP challenges.</li>
                        </ul>
                    </li>
                    <li>Publishes in DID Document:
                        <ul>
                            <li>The commitments <code>C<sub>j</sub></code>.</li>
                            <li>The group parameters (p, q, g).</li>
                            <li>Guardian identifiers and endpoints.</li>
                            <li>Threshold <code>t</code>.</li>
                        </ul>
                    </li>
                </ol>

                <h4>5.1.3 Recovery Phase</h4>
                <p>To recover:</p>
                <ol>
                    <li>Recovering party contacts <code>t</code> guardians.</li>
                    <li>Each guardian generates a Schnorr ZKP (§7.2) proving knowledge of share <code>s<sub>i</sub></code> consistent with commitments <code>C<sub>j</sub></code>, without revealing <code>s<sub>i</sub></code>.</li>
                    <li>ZKPs are verified and shares are reconstructed using Lagrange interpolation in <code>Z<sub>q</sub></code> (§7.1.2).</li>
                    <li>The reconstructed secret <code>s</code> is used to generate new DID keys.</li>
                </ol>

                <h4>5.1.4 DID Document Representation</h4>
                <pre><code class="language-json">{
  "id": "did:example:123#recovery-social",
  "type": "RecoveryMethodZKPSocial",
  "controller": "did:example:123",
  "recoveryThreshold": 3,
  "vssScheme": "feldman-safe-prime-256-2025",
  "vssGroupParameters": {
    "p": "0x50179e4375e428b3af8fe52af1f2a50e5100b916d0d1c1bbedc304c3d35f3217",
    "q": "0x280bcf21baf21459d7c7f29578f9528728805c8b6868e0ddf6e18261e9af990b",
    "g": "4"
  },
  "recoveryGuardians": [
    {
      "id": "did:guardian:abc#key-1",
      "guardianEndpoint": "https://guardian1.example.com/recover",
      "guardianType": "person",
      "commitmentIndex": 0
    },
    {
      "id": "did:guardian:def#key-1",
      "guardianEndpoint": "https://guardian2.example.com/recover",
      "guardianType": "institution",
      "commitmentIndex": 1
    },
    {
      "id": "did:guardian:ghi#key-1",
      "guardianEndpoint": "https://guardian3.example.com/recover",
      "guardianType": "hardware",
      "commitmentIndex": 2
    }
  ],
  "vssCommitments": [
    "0x04a5...c3f2",
    "0x07b2...d1e4",
    "0x02c8...a9b6"
  ],
  "curve": "safe-prime-256"
}</code></pre>

                <div class="diagram-container">
                    <div class="diagram-title">Figure 1: Type A — Social ZKP Recovery Flow</div>
                    <div class="mermaid">
                        sequenceDiagram
                            participant User as User (Recovering Party)
                            participant G1 as Guardian 1
                            participant G2 as Guardian 2
                            participant G3 as Guardian 3
                            participant Aggregator as ZKP Aggregator
                            
                            Note over User: Initiates recovery (threshold=3)
                            
                            User->>G1: Request recovery (nonce, commitments)
                            User->>G2: Request recovery (nonce, commitments)
                            User->>G3: Request recovery (nonce, commitments)
                            
                            G1->>G1: Generate Schnorr ZKP (share vs C_j)
                            G2->>G2: Generate Schnorr ZKP (share vs C_j)
                            G3->>G3: Generate Schnorr ZKP (share vs C_j)
                            
                            G1-->>User: ZKP Proof 1
                            G2-->>User: ZKP Proof 2
                            G3-->>User: ZKP Proof 3
                            
                            User->>Aggregator: Submit proofs (threshold=3)
                            Aggregator->>Aggregator: Verify ZKPs against C_j (mod p)
                            Aggregator->>Aggregator: Lagrange interpolation in Z_q
                            
                            Aggregator-->>User: Recovered secret s
                            User->>User: Generate new DID keys
                            User->>DID Method: Update DID Document
                    </div>
                </div>
            </section>

            <!-- Type B -->
            <section id="type-b">
                <h3>5.2 Type B: Deterministic Seedling Inheritance</h3>
                <p><strong>Type URI:</strong> <code>RecoveryMethodDeterministic</code></p>
                <p>
                    The Deterministic Seedling mechanism enables recovery through a master seed phrase, with 
                    optional time-locked inheritance for beneficiaries.
                </p>

                <h4>5.2.1 Cryptographic Requirements</h4>
                <p>Implementations MUST use:</p>
                <ul>
                    <li><strong>Hierarchical Deterministic Keys:</strong> BIP-32 or BIP-39 style derivation.</li>
                    <li><strong>Encryption:</strong> XChaCha20-Poly1305 for seed lockbox.</li>
                    <li><strong>Time-Locks:</strong> Verifiable Delay Functions (VDFs) for decentralized inheritance.</li>
                    <li><strong>VDF Algorithm:</strong> Wesolowski's VDF or Pietrzak's VDF.</li>
                </ul>

                <h4>5.2.2 Setup Phase</h4>
                <p>The DID Controller:</p>
                <ol>
                    <li>Generates a master seed <code>S</code> (128–256 bits of entropy).</li>
                    <li>Derives the DID private key using a standardized derivation path.</li>
                    <li>If inheritance desired:
                        <ul>
                            <li>Generates a VDF modulus <code>N</code> and challenge <code>x</code>.</li>
                            <li>Computes VDF output <code>y = x<sup>2<sup>T</sup></sup> mod N</code>.</li>
                            <li>Uses <code>y</code> to derive encryption key for seed lockbox.</li>
                        </ul>
                    </li>
                    <li>Encrypts seed <code>S</code> to beneficiary's public key.</li>
                    <li>Publishes in DID Document: derivation path, encrypted seed lockbox, and VDF parameters.</li>
                </ol>

                <h4>5.2.3 Recovery Phase</h4>
                <p>For self-recovery:</p>
                <ol>
                    <li>User enters seed phrase.</li>
                    <li>Wallet re-derives keys using the specified derivation path.</li>
                    <li>DID Document is updated with new keys.</li>
                </ol>
                <p>For inheritance:</p>
                <ol>
                    <li>Beneficiary waits for the inactivity period.</li>
                    <li>Computes VDF for the specified time parameter.</li>
                    <li>Derives decryption key from VDF output.</li>
                    <li>Decrypts seed lockbox and recovers DID keys.</li>
                </ol>

                <h4>5.2.4 DID Document Representation</h4>
                <pre><code class="language-json">{
  "id": "did:example:123#recovery-seedling",
  "type": "RecoveryMethodDeterministic",
  "controller": "did:example:123",
  "seedDerivationPath": "m/44'/0'/0'/0/0",
  "derivationStandard": "bip32-ed25519",
  "encryptedSeedLockbox": {
    "ciphertext": "0x7b3a...f9c2",
    "algorithm": "XChaCha20-Poly1305",
    "iv": "0x1a2b...3c4d",
    "beneficiaryPublicKey": "did:beneficiary:abc#key-1",
    "beneficiaryKeyType": "x25519"
  },
  "deadMansSwitch": {
    "type": "VDFTimeLock",
    "vdfParameters": {
      "difficulty": 1000000,
      "estimatedWallTime": "P30D",
      "referencePlatform": "intel-i9-13900k-2024",
      "tolerance": 0.2,
      "modulus": "0x8f3b...a1c4",
      "challenge": "0x2d4e...f8a1",
      "vdfAlgorithm": "wesolowski-2024"
    },
    "inactivityPeriod": "P1Y"
  }
}</code></pre>

                <div class="diagram-container">
                    <div class="diagram-title">Figure 2: Type B — VDF Time-Locked Inheritance</div>
                    <div class="mermaid">
                        sequenceDiagram
                            participant User as Original User
                            participant Beneficiary as Beneficiary
                            participant VDF as VDF Computation
                            participant DID as DID Method
                            
                            Note over User: Setup Phase
                            User->>User: Generate master seed
                            User->>User: Encrypt seed with VDF-derived key
                            User->>DID: Publish encrypted lockbox + VDF params
                            
                            Note over User: User becomes inactive
                            
                            Beneficiary->>VDF: Compute VDF (difficulty=1M)
                            VDF->>VDF: Sequential squaring (~30 days)
                            VDF-->>Beneficiary: VDF output + Wesolowski proof
                            
                            Beneficiary->>Beneficiary: Derive decryption key from VDF output
                            Beneficiary->>Beneficiary: Decrypt seed lockbox
                            Beneficiary->>Beneficiary: Derive DID keys
                            Beneficiary->>DID: Update DID Document with new controller
                    </div>
                </div>
            </section>

            <!-- Type C -->
            <section id="type-c">
                <h3>5.3 Type C: MPC-Mediated Recovery</h3>
                <p><strong>Type URI:</strong> <code>RecoveryMethodMPC</code></p>
                <p>
                    The MPC-Mediated Recovery mechanism distributes key shares across multiple independent 
                    providers who perform threshold signatures without reconstructing the full key.
                </p>

                <h4>5.3.1 Cryptographic Requirements</h4>
                <p>Implementations MUST use:</p>
                <ul>
                    <li><strong>Threshold Signatures:</strong> fROST (Flexible Round-Optimized Schnorr Threshold) signatures.</li>
                    <li><strong>Proactive Secret Sharing:</strong> Share refreshment as specified in §7.1.3.</li>
                    <li><strong>Authentication:</strong> Verifiable Credentials or WebAuthn for user authentication to providers.</li>
                    <li><strong>Transport:</strong> mTLS or Noise Protocol for secure provider communication.</li>
                </ul>

                <h4>5.3.2 Setup Phase</h4>
                <p>The DID Controller:</p>
                <ol>
                    <li>Generates a threshold key pair with <code>t-of-n</code> providers.</li>
                    <li>Distributes shares to providers via secure channels.</li>
                    <li>Establishes authentication credentials with each provider.</li>
                    <li>Publishes in DID Document: provider endpoints, threshold parameters, and share rotation schedule.</li>
                </ol>

                <h4>5.3.3 Recovery Phase</h4>
                <p>To recover:</p>
                <ol>
                    <li>User authenticates to <code>t</code> providers using established credentials.</li>
                    <li>Providers verify user authentication and check for any revocation.</li>
                    <li>Providers engage in fROST signing protocol to generate a signature authorizing DID update.</li>
                    <li>The signature is used to create a new DID Document with fresh keys.</li>
                </ol>

                <h4>5.3.4 Share Refreshment</h4>
                <p>Providers MUST support periodic share refreshment using the proactive refresh protocol defined in §7.1.3. After each refresh:</p>
                <ol>
                    <li>Each provider's share changes, but the secret and group public key remain identical.</li>
                    <li>Combined commitments are updated: <code>C<sub>j</sub><sup>new</sup> = C<sub>j</sub><sup>old</sup> · g<sup>r<sub>j</sub></sup> mod p</code>.</li>
                    <li>Old shares are securely deleted.</li>
                    <li>The epoch counter is incremented.</li>
                </ol>

                <h4>5.3.5 DID Document Representation</h4>
                <pre><code class="language-json">{
  "id": "did:example:123#recovery-mpc",
  "type": "RecoveryMethodMPC",
  "controller": "did:example:123",
  "mpcThreshold": 2,
  "mpcTotalProviders": 3,
  "mpcProtocol": "fROST-ed25519-2024",
  "mpcProviders": [
    {
      "id": "did:provider:one#mpc-node",
      "endpoint": "https://provider1.example.com/mpc",
      "authType": "vc-presentation",
      "authRequirements": {
        "credentialType": "MpcProviderCredential",
        "trustFramework": "did-kr-provider-v1"
      },
      "providerKey": "did:provider:one#key-1"
    },
    {
      "id": "did:provider:two#mpc-node",
      "endpoint": "https://provider2.example.com/mpc",
      "authType": "passkey",
      "authRequirements": {
        "rpId": "provider2.example.com",
        "algorithm": "es256"
      },
      "providerKey": "did:provider:two#key-1"
    },
    {
      "id": "did:provider:three#mpc-node",
      "endpoint": "https://provider3.example.com/mpc",
      "authType": "oauth2",
      "authRequirements": {
        "issuer": "https://auth.provider3.example.com",
        "scope": "did-recovery"
      },
      "providerKey": "did:provider:three#key-1"
    }
  ],
  "shareRotation": {
    "rotationInterval": "P30D",
    "currentEpoch": 2,
    "providerStateEndpoint": "https://provider1.example.com/state",
    "lastRotationProof": "0x8a3c...f2b5"
  }
}</code></pre>

                <div class="diagram-container">
                    <div class="diagram-title">Figure 3: Type C — MPC Recovery with Epoch Catch-up</div>
                    <div class="mermaid">
                        sequenceDiagram
                            participant User as User
                            participant P1 as Provider 1 (Epoch 42)
                            participant P2 as Provider 2 (Epoch 42)
                            participant P3 as Provider 3 (Epoch 41)
                            participant Coord as MPC Coordinator
                            
                            User->>P1: Authenticate
                            User->>P2: Authenticate
                            User->>P3: Authenticate
                            
                            P1-->>User: Auth OK (epoch=42)
                            P2-->>User: Auth OK (epoch=42)
                            P3-->>User: Auth OK (epoch=41)
                            
                            Note over User: Detects epoch skew on P3
                            
                            User->>P3: Request catch-up
                            P3->>P1: Request refresh transcript (41→42)
                            P1-->>P3: Verifiable refresh proof
                            P3->>P3: Verify and update share to epoch 42
                            P3-->>User: Ready (epoch=42)
                            
                            User->>Coord: Initiate MPC signing
                            Coord->>P1: Signing request (nonce)
                            Coord->>P2: Signing request (nonce)
                            Coord->>P3: Signing request (nonce)
                            
                            P1-->>Coord: Partial signature 1
                            P2-->>Coord: Partial signature 2
                            P3-->>Coord: Partial signature 3
                            
                            Coord->>Coord: Aggregate (threshold=2)
                            Coord-->>User: Final signature
                            User->>DID Method: Update DID Document
                    </div>
                </div>
            </section>

            <!-- Provider State Synchronization -->
            <section id="provider-sync">
                <h3>5.4 Provider State Synchronization (Normative)</h3>
                <p>
                    When providers operate at different epochs, the recovery protocol MUST handle version skew 
                    to prevent state drift from becoming a single point of failure.
                </p>

                <h4>5.4.1 Epoch Discovery</h4>
                <p>
                    During recovery initiation, each provider MUST include their <code>currentEpoch</code> in 
                    the authentication response.
                </p>

                <h4>5.4.2 Lag Detection</h4>
                <p>The recovering party MUST compare epochs from all responding providers:</p>
                <ol>
                    <li>Determine the majority epoch.</li>
                    <li>Any provider more than <code>maxEpochSkew</code> (RECOMMENDED: 1) behind the majority MUST be excluded from the signing ceremony until caught up.</li>
                </ol>

                <h4>5.4.3 Automatic Catch-up Protocol</h4>
                <ol>
                    <li>
                        <strong>Catch-up Request:</strong> The lagging provider sends a signed request specifying <code>currentEpoch</code> and <code>targetEpoch</code>.
                    </li>
                    <li>
                        <strong>Verifiable Refresh Transcript:</strong> Up-to-date providers respond with the group public key and a cryptographically verifiable transcript of each refresh operation between the two epochs.
                    </li>
                    <li>
                        <strong>Verification and Update:</strong> The lagging provider verifies each transcript, updates their local share, and securely deletes the old share.
                    </li>
                    <li><strong>Confirmation:</strong> Provider confirms readiness to the recovering party.</li>
                </ol>

                <h4>5.4.4 DID Document Parameters</h4>
                <pre><code class="language-json">"shareRotation": {
  "rotationInterval": "P30D",
  "currentEpoch": 42,
  "providerStateEndpoint": "https://provider1.example.com/state",
  "lastRotationProof": "0x8a3c...f2b5",
  "synchronization": {
    "maxEpochSkew": 1,
    "catchupProtocol": "vss-refresh-verifiable-2025",
    "timeout": "PT30S",
    "requiredQuorum": 2
  }
}</code></pre>
            </section>
        </section>

        <!-- Verification Relationships -->
        <section id="verification-relationships">
            <h2>6. Verification Relationships</h2>

            <h3>6.1 The <code>recovery</code> Relationship</h3>
            <p>
                The <code>recovery</code> verification relationship indicates that the associated verification 
                methods are specifically authorized for recovering control of the DID. These methods MUST NOT 
                be used for general authentication.
            </p>

            <pre><code class="language-json">{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://sirraya.org/ns/did/recovery/v1"
  ],
  "id": "did:example:123",
  "recovery": [
    "did:example:123#recovery-social",
    "did:example:123#recovery-seedling",
    "did:example:123#recovery-mpc"
  ]
}</code></pre>

            <h3>6.2 Processing Rules</h3>
            <ol>
                <li>The resolver MUST verify that the recovery method is listed in the <code>recovery</code> relationship.</li>
                <li>The resolver MUST verify that the recovery method's <code>controller</code> is authorized to modify the DID Document.</li>
                <li>The resolver MUST perform dependency checking to prevent recovery loops (see §8.4).</li>
            </ol>
        </section>

        <!-- Cryptographic Primitives -->
        <section id="crypto-primitives">
            <h2>7. Cryptographic Primitives</h2>

            <!-- §7.0 NEW -->
            <section id="vss-group">
                <h3>7.0 VSS Group Parameters <span class="tag tag-new">NEW in rev 2.1</span></h3>

                <div class="warning">
                    <strong>Correction Notice (rev 1.x → 2.1):</strong> The original specification incorrectly 
                    stated that VSS could be instantiated using the secp256k1 scalar order <em>N</em> as both 
                    the polynomial field modulus and the group modulus for commitments. This is mathematically 
                    invalid and caused share verification to fail for all participant indices ≥ 2. 
                    This section and §7.1 are normatively corrected.
                </div>

                <h4>7.0.1 Why a Dedicated Group is Required</h4>
                <p>Feldman VSS verification requires the equation:</p>
                <div class="math-block">
g<sup>s<sub>i</sub></sup>  ≡  ∏<sub>j=0</sub><sup>t−1</sup>  C<sub>j</sub><sup>i<sup>j</sup></sup>  (mod p)
                </div>
                <p>For this to hold consistently, exponents on both sides must reduce modulo the same value — the order of generator <em>g</em> in the group. This requires:</p>
                <ol>
                    <li>A scalar field of prime order <strong>q</strong> for polynomial arithmetic (shares, coefficients, Lagrange interpolation).</li>
                    <li>A group prime <strong>p</strong> with <strong>q | (p−1)</strong>, so a subgroup of order exactly <strong>q</strong> exists in Z<sub>p</sub>*.</li>
                    <li>A generator <strong>g</strong> of order exactly <strong>q</strong> in Z<sub>p</sub>*.</li>
                </ol>
                <p>
                    Using a single prime for both roles (as in the previous revision, which reused secp256k1's N) 
                    breaks consistency because <em>g</em> has order dividing N−1, not N itself. Reducing exponents 
                    mod N while the generator has order dividing N−1 causes verification to diverge at all 
                    non-trivial evaluation points.
                </p>

                <h4>7.0.2 Mandatory Group Parameters</h4>
                <p>Implementations MUST use the following parameters, or an equivalent set satisfying all properties in §7.0.3:</p>

                <div class="param-table">
                    <div class="row"><span class="key">p</span><span class="val">0x50179e4375e428b3af8fe52af1f2a50e5100b916d0d1c1bbedc304c3d35f3217</span></div>
                    <div class="row"><span class="key">q</span><span class="val">0x280bcf21baf21459d7c7f29578f9528728805c8b6868e0ddf6e18261e9af990b</span></div>
                    <div class="row"><span class="key">g</span><span class="val">4</span></div>
                    <div class="row"><span class="key">type</span><span class="val">256-bit safe prime (p = 2q+1)</span></div>
                </div>

                <h4>7.0.3 Parameter Verification</h4>
                <p>Any implementation MUST verify the following properties hold:</p>
                <div class="algorithm">
<pre>isPrime(p)       == True    # p is prime
isPrime(q)       == True    # q is prime
p                == 2*q + 1  # safe prime relationship
pow(g, q, p)     == 1       # g has order exactly q
pow(g, 1, p)     != 1       # g is not the identity</pre>
                </div>

                <h4>7.0.4 Alternative Parameters</h4>
                <p>
                    Implementations MAY use alternative parameters of equivalent or greater security, provided 
                    they satisfy all properties in §7.0.3 and publish the parameters in the DID Document's 
                    <code>vssGroupParameters</code> field.
                </p>
            </section>

            <!-- §7.1 UPDATED -->
            <section id="feldman-vss">
                <h3>7.1 Verifiable Secret Sharing (Feldman's VSS) <span class="tag tag-updated">UPDATED in rev 2.1</span></h3>

                <p>
                    Let <code>(p, q, g)</code> be as defined in §7.0. All scalar operations (polynomial 
                    evaluation, Lagrange interpolation) are in <strong>Z<sub>q</sub></strong>. All commitment 
                    (group) operations are in <strong>Z<sub>p</sub></strong>.
                </p>

                <h4>7.1.1 Share Generation</h4>
                <ol>
                    <li>Dealer chooses secret <code>s ∈ Z<sub>q</sub></code> and random coefficients <code>a<sub>1</sub>, …, a<sub>t−1</sub> ←<sub>R</sub> Z<sub>q</sub></code>.</li>
                    <li>Forms polynomial <code>P(x) = s + a<sub>1</sub>x + … + a<sub>t−1</sub>x<sup>t−1</sup></code> over <code>Z<sub>q</sub></code>.</li>
                    <li>For participant <code>i = 1…n</code>, computes share <code>s<sub>i</sub> = P(i) mod q</code>.</li>
                    <li>Computes Feldman commitments: <code>C<sub>j</sub> = g<sup>a<sub>j</sub></sup> mod p</code> for <code>j = 0…t−1</code>.</li>
                </ol>

                <h4>7.1.2 Share Verification</h4>
                <p>Participant <code>i</code> verifies their share by checking (all arithmetic mod p, exponents mod q):</p>
                <div class="math-block">
g<sup>s<sub>i</sub></sup>  ≡  ∏<sub>j=0</sub><sup>t−1</sup>  C<sub>j</sub><sup>i<sup>j</sup> mod q</sup>  (mod p)
                </div>
                <p>
                    This holds because <code>ord(g) = q</code>, so <code>g<sup>x mod q</sup> = g<sup>x</sup> mod p</code> 
                    for any integer x.
                </p>

                <div class="note">
                    <strong>Implementation Note:</strong> Exponents <code>i<sup>j</sup></code> MUST be reduced 
                    modulo <code>q</code> (the scalar field order). Reducing by any other value — 
                    <code>q−1</code>, <code>p−1</code>, or N from secp256k1 — breaks the consistency 
                    and is the root cause of the pre-revision verification failures.
                </div>

                <p>Secret recovery: given <code>t</code> shares <code>{(i, s<sub>i</sub>)}</code>, recover <code>s = P(0)</code> via Lagrange interpolation in <code>Z<sub>q</sub></code>:</p>
                <div class="math-block">
s  =  ∑<sub>j</sub>  s<sub>j</sub> · L<sub>j</sub>(0)  mod q<br><br>
L<sub>j</sub>(0)  =  ∏<sub>m≠j</sub>  (0 − x<sub>m</sub>) / (x<sub>j</sub> − x<sub>m</sub>)  mod q
                </div>
                <p>Division is computed as multiplication by the modular inverse: <code>a<sup>−1</sup> mod q = a<sup>q−2</sup> mod q</code> (Fermat's little theorem; q is prime).</p>

                <h4>7.1.3 Proactive Share Refreshment <span class="tag tag-new">NEW in rev 2.1</span></h4>
                <p>To re-randomize shares without changing the underlying secret:</p>
                <ol>
                    <li>Generate refresh polynomial <code>R(x) = r<sub>1</sub>x + … + r<sub>t−1</sub>x<sup>t−1</sup></code> over <code>Z<sub>q</sub></code> with <code>R(0) = 0</code>.</li>
                    <li>Compute refresh shares <code>δ<sub>i</sub> = R(i) mod q</code> and refresh commitments <code>D<sub>j</sub> = g<sup>r<sub>j</sub></sup> mod p</code>.</li>
                    <li>Update each share: <code>s<sub>i</sub><sup>new</sup> = (s<sub>i</sub><sup>old</sup> + δ<sub>i</sub>) mod q</code>.</li>
                    <li>Update commitments: <code>C<sub>j</sub><sup>new</sup> = C<sub>j</sub><sup>old</sup> · D<sub>j</sub> mod p = g<sup>a<sub>j</sub> + r<sub>j</sub></sup> mod p</code>.</li>
                    <li>Secret is preserved: <code>P<sup>new</sup>(0) = P<sup>old</sup>(0) + R(0) = s + 0 = s</code>.</li>
                    <li>Each refreshed share MUST be verified against the combined commitments before the old share is deleted.</li>
                </ol>
            </section>

            <!-- §7.2 ZKP -->
            <section id="zkp">
                <h3>7.2 Zero-Knowledge Proof of Share</h3>
                <p>To prove knowledge of share <code>s<sub>i</sub> ∈ Z<sub>q</sub></code> without revealing it (Schnorr; all operations mod p/q as appropriate):</p>
                <ol>
                    <li>Prover chooses random <code>r ← Z<sub>q</sub></code>.</li>
                    <li>Prover sends <code>R = g<sup>r</sup> mod p</code>.</li>
                    <li>Verifier sends challenge <code>c ← Z<sub>q</sub></code>.</li>
                    <li>Prover sends <code>z = (r + c · s<sub>i</sub>) mod q</code>.</li>
                    <li>Verifier checks: <code>g<sup>z</sup> ≡ R · (∏ C<sub>j</sub><sup>i<sup>j</sup> mod q</sup>)<sup>c</sup> (mod p)</code>.</li>
                </ol>
            </section>

            <!-- §7.3 VDF -->
            <section id="vdf">
                <h3>7.3 Verifiable Delay Function (Wesolowski)</h3>
                <p>
                    <strong>Input:</strong> <code>x ∈ QR(N)</code>, time parameter <code>T</code><br>
                    <strong>Output:</strong> <code>y = x<sup>2<sup>T</sup></sup> mod N</code>, proof <code>π</code>
                </p>
                <ol>
                    <li>Compute <code>y = x<sup>2<sup>T</sup></sup> mod N</code> via sequential squaring.</li>
                    <li>Let <code>l = ⌊2<sup>T</sup> / 2⌋</code>, compute <code>π = x<sup>l</sup> mod N</code>.</li>
                    <li>Verifier checks: <code>π<sup>2<sup>(T/2)</sup></sup> · x<sup>2<sup>T</sup> mod 2<sup>(T/2)</sup></sup> = y mod N</code>.</li>
                </ol>

                <h3>7.4 VDF Parameter Calibration (Normative)</h3>

                <h4>7.4.1 Difficulty Units</h4>
                <p>
                    Difficulty is measured in sequential squaring operations estimated to require a specific 
                    wall-clock time on a reference implementation.
                </p>

                <h4>7.4.2 Reference Platform</h4>
                <ul>
                    <li><strong>CPU:</strong> Intel i9-13900K (or equivalent), single-threaded execution</li>
                    <li><strong>Memory:</strong> 32GB DDR5 RAM</li>
                    <li><strong>Implementation:</strong> Optimized C with GMP library</li>
                    <li><strong>OS:</strong> Linux kernel 6.1 or newer</li>
                </ul>

                <h4>7.4.3 Published Parameters</h4>
                <pre><code class="language-json">"vdfParameters": {
  "difficulty": 1000000,
  "estimatedWallTime": "P30D",
  "referencePlatform": "intel-i9-13900k-2024",
  "tolerance": 0.2,
  "verificationMode": "wesolowski-optimistic"
}</code></pre>
            </section>

            <!-- §7.5 fROST -->
            <section id="frost">
                <h3>7.5 fROST Threshold Signatures</h3>
                <p>fROST enables <code>t-of-n</code> threshold Schnorr signatures:</p>
                <ol>
                    <li><strong>Key Generation:</strong> Distributed key generation produces group public key and individual secret shares.</li>
                    <li><strong>Signing:</strong> Each participant generates a nonce and commitment.</li>
                    <li><strong>Aggregation:</strong> Coordinator aggregates commitments and challenges.</li>
                    <li><strong>Response:</strong> Each participant responds with partial signatures.</li>
                    <li><strong>Finalization:</strong> Coordinator aggregates partial signatures into final signature.</li>
                </ol>
            </section>
        </section>

        <!-- Security Considerations -->
        <section id="security-considerations">
            <h2>8. Security Considerations</h2>

            <h3>8.1 Guardian Collusion (Type A)</h3>
            <p><strong>Threat:</strong> A threshold of guardians collude to reconstruct the user's private key.</p>
            <p><strong>Mitigation:</strong> Feldman VSS ensures shares are individually verifiable. Guardians SHOULD be selected from diverse trust domains, and threshold SHOULD be ≥ 3-of-5.</p>

            <h3>8.2 Time-Lock Bypass (Type B)</h3>
            <p><strong>Threat:</strong> An attacker compromises the dead man's switch to release inheritance keys prematurely.</p>
            <p><strong>Mitigation:</strong> VDFs provide computational asymmetry that cannot be parallelized, making premature release computationally infeasible within the specified time window.</p>

            <h3>8.3 Provider State Drift (Type C)</h3>
            <p><strong>Threat:</strong> MPC providers update shares independently, causing key desynchronization.</p>
            <p><strong>Mitigation:</strong> Proactive Secret Sharing with verifiable refresh transcripts (§7.1.3) ensures consistency. The catch-up protocol (§5.4.3) handles epoch lag.</p>

            <h3>8.4 Recovery-Loop Prevention</h3>
            <p><strong>Threat:</strong> Circular recovery dependencies make recovery impossible.</p>
            <p><strong>Mitigation:</strong> Implementations MUST validate that the dependency graph of recovery methods is acyclic at publication time, at recovery initiation, and during periodic health checks.</p>
            
            <div class="algorithm">
                <pre>function checkAcyclic(did, visited = new Set()):
  if visited.has(did): return false
  visited.add(did)
  for each recoveryMethod in resolve(did).recovery:
    for each guardian in recoveryMethod.guardians:
      if guardian.id is DID:
        if not checkAcyclic(guardian.id, visited):
          return false
  visited.delete(did)
  return true</pre>
            </div>

            <div class="diagram-container">
                <div class="diagram-title">Figure 4: Recovery-Loop Detection</div>
                <div class="mermaid">
                    graph TD
                        subgraph bad["Graph 1: Loop Detected ✗"]
                            A1[did:example:123] -->|recovery| B1[did:guardian:abc]
                            B1 -->|controller| A1
                        end
                        
                        subgraph good["Graph 2: Valid Tree ✓"]
                            A2[did:example:456] -->|recovery| C2[did:guardian:def]
                            A2 -->|recovery| D2[did:guardian:ghi]
                        end
                        
                        style A1 fill:#fee2e2,stroke:#ef4444,stroke-width:4px
                        style B1 fill:#fee2e2,stroke:#ef4444,stroke-width:2px
                        style A2 fill:#dcfce7,stroke:#22c55e,stroke-width:4px
                        style C2 fill:#dcfce7,stroke:#22c55e,stroke-width:2px
                        style D2 fill:#dcfce7,stroke:#22c55e,stroke-width:2px
                </div>
            </div>

            <h3>8.5 Key Wrapping Security</h3>
            <p><strong>Threat:</strong> Weak encryption of seed lockboxes.</p>
            <p><strong>Mitigation:</strong> All encrypted payloads MUST use AEAD with ≥ 256-bit keys. XChaCha20-Poly1305 or AES-256-GCM are REQUIRED. The algorithm MUST be explicitly named in the DID Document.</p>

            <h3>8.6 Quantum Computing Resistance</h3>
            <p>Current algorithms are secure against classical computers. Implementations SHOULD plan transition paths:</p>
            <ul>
                <li><strong>Type A:</strong> Consider lattice-based VSS for post-quantum security.</li>
                <li><strong>Type B:</strong> Use hash-based signatures for seed commitment.</li>
                <li><strong>Type C:</strong> Transition to threshold lattice signatures when standardized.</li>
            </ul>
        </section>

        <!-- Privacy Considerations -->
        <section id="privacy-considerations">
            <h2>9. Privacy Considerations</h2>

            <h3>9.1 Metadata Leakage</h3>
            <p>Recovery methods may leak social graph (guardian identities), security posture (threshold values), and activity patterns. Mitigations include encrypted DID Document entries, guardian anonymity via onion services, and minimum-disclosure design.</p>

            <h3>9.2 Guardian Privacy (Enhanced)</h3>

            <h4>9.2.1 Hashed Guardian Identifiers (RECOMMENDED)</h4>
            <p>Instead of publishing full guardian DIDs, implementations SHOULD publish salted hashes:</p>
            <pre><code class="language-json">"recoveryGuardians": [
  {
    "id": "urn:hash:sha256:3a7b...c9f2",
    "salt": "0x4d8e...f2a3",
    "guardianEndpoint": "http://guardian1.onion/recover",
    "commitmentIndex": 0
  }
]</code></pre>

            <h4>9.2.2 Fully Encrypted Recovery Section (OPTIONAL)</h4>
            <p>For maximum privacy, the entire <code>recovery</code> relationship MAY be stored off-chain:</p>
            <pre><code class="language-json">{
  "recovery": "ipfs://QmXyZ...abc123",
  "recoveryProof": "0x8a3c...f2b5"
}</code></pre>

            <h3>9.3 Correlation Risk</h3>
            <p>The same recovery method across multiple DIDs could correlate them. DID controllers SHOULD use different guardian sets, salt values, and encryption keys per DID.</p>

            <h3>9.4 Beneficiary Privacy</h3>
            <p>Beneficiaries SHOULD use single-use derived keys specific to each inheritance relationship, not linked to their primary identity.</p>
        </section>

        <!-- Interoperability -->
        <section id="interoperability">
            <h2>10. Interoperability Requirements</h2>

            <h3>10.1 Mandatory-to-Implement Algorithms</h3>
            <table>
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Usage</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>Ed25519</td><td>Signatures, guardian keys</td></tr>
                    <tr><td>SHA-256</td><td>Hashing</td></tr>
                    <tr><td>XChaCha20-Poly1305</td><td>Seed lockbox encryption</td></tr>
                    <tr><td>AES-256-GCM</td><td>Share encryption at rest</td></tr>
                    <tr><td>BIP-32</td><td>Key derivation</td></tr>
                    <tr><td>fROST (Ed25519)</td><td>Threshold signatures</td></tr>
                    <tr><td>Feldman VSS (p,q,g per §7.0)</td><td>Verifiable secret sharing</td></tr>
                    <tr><td>Wesolowski VDF</td><td>Time-locks</td></tr>
                    <tr><td>PBKDF2-SHA256 (100k iter)</td><td>Seed derivation</td></tr>
                </tbody>
            </table>

            <h3>10.2 Optional Algorithms</h3>
            <table>
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Usage</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>secp256k1</td><td>Blockchain compatibility (NOT for VSS group)</td></tr>
                    <tr><td>BLS12-381</td><td>Pairing-based cryptography</td></tr>
                    <tr><td>Pietrzak VDF</td><td>Alternative time-locks</td></tr>
                    <tr><td>Dilithium</td><td>Post-quantum signatures</td></tr>
                    <tr><td>Kyber</td><td>Post-quantum encryption</td></tr>
                </tbody>
            </table>

            <h3>10.3 DID Method Compatibility</h3>
            <p>This specification is DID method agnostic but requires methods that support DID Document updates, resolution for recovery method discovery, and deactivation of compromised recovery methods.</p>
        </section>

        <!-- JSON-LD Context -->
        <section id="json-ld-context">
            <h2>11. JSON-LD Context</h2>
            <p>Available at: <code>https://sirraya.org/ns/did/recovery/v1.jsonld</code></p>
            <pre><code class="language-json">{
  "@context": {
    "@version": 1.1,
    "@protected": true,
    
    "id": "@id",
    "type": "@type",
    
    "RecoveryMethod": "https://sirraya.org/ns/did/recovery#RecoveryMethod",
    "RecoveryMethodZKPSocial": "https://sirraya.org/ns/did/recovery#RecoveryMethodZKPSocial",
    "RecoveryMethodDeterministic": "https://sirraya.org/ns/did/recovery#RecoveryMethodDeterministic",
    "RecoveryMethodMPC": "https://sirraya.org/ns/did/recovery#RecoveryMethodMPC",
    
    "recovery": {
      "@id": "https://sirraya.org/ns/did/recovery#recovery",
      "@type": "@id",
      "@container": "@set"
    },
    "recoveryThreshold": {
      "@id": "https://sirraya.org/ns/did/recovery#recoveryThreshold",
      "@type": "xsd:integer"
    },
    "vssGroupParameters": {
      "@id": "https://sirraya.org/ns/did/recovery#vssGroupParameters",
      "@type": "@id"
    },
    "vssScheme": {
      "@id": "https://sirraya.org/ns/did/recovery#vssScheme",
      "@type": "xsd:string"
    },
    "recoveryGuardians": {
      "@id": "https://sirraya.org/ns/did/recovery#recoveryGuardians",
      "@type": "@id",
      "@container": "@set"
    },
    "guardianEndpoint": {
      "@id": "https://sirraya.org/ns/did/recovery#guardianEndpoint",
      "@type": "xsd:anyURI"
    },
    "vssCommitments": {
      "@id": "https://sirraya.org/ns/did/recovery#vssCommitments",
      "@type": "xsd:string",
      "@container": "@list"
    },
    "seedDerivationPath": {
      "@id": "https://sirraya.org/ns/did/recovery#seedDerivationPath",
      "@type": "xsd:string"
    },
    "encryptedSeedLockbox": {
      "@id": "https://sirraya.org/ns/did/recovery#encryptedSeedLockbox",
      "@type": "@id"
    },
    "deadMansSwitch": {
      "@id": "https://sirraya.org/ns/did/recovery#deadMansSwitch",
      "@type": "@id"
    },
    "vdfParameters": {
      "@id": "https://sirraya.org/ns/did/recovery#vdfParameters",
      "@type": "@id"
    },
    "mpcThreshold": {
      "@id": "https://sirraya.org/ns/did/recovery#mpcThreshold",
      "@type": "xsd:integer"
    },
    "mpcProviders": {
      "@id": "https://sirraya.org/ns/did/recovery#mpcProviders",
      "@type": "@id",
      "@container": "@set"
    },
    "shareRotation": {
      "@id": "https://sirraya.org/ns/did/recovery#shareRotation",
      "@type": "@id"
    },
    "currentEpoch": {
      "@id": "https://sirraya.org/ns/did/recovery#currentEpoch",
      "@type": "xsd:integer"
    },
    "synchronization": {
      "@id": "https://sirraya.org/ns/did/recovery#synchronization",
      "@type": "@id"
    },
    "maxEpochSkew": {
      "@id": "https://sirraya.org/ns/did/recovery#maxEpochSkew",
      "@type": "xsd:integer"
    },
    "catchupProtocol": {
      "@id": "https://sirraya.org/ns/did/recovery#catchupProtocol",
      "@type": "xsd:string"
    }
  }
}</code></pre>
        </section>

        <!-- Protocol Flows -->
        <section id="protocol-flows">
            <h2>12. Recovery Protocol Flows</h2>

            <h3>12.1 Type A Recovery Protocol</h3>
            <p><strong>Request:</strong></p>
            <pre><code class="language-http">POST /recover HTTP/1.1
Host: guardian1.example.com
Content-Type: application/json

{
  "protocol": "did-kr-recovery-v1",
  "recoveryId": "did:example:123#recovery-social",
  "did": "did:example:123",
  "nonce": "a1b2c3d4e5f6...",
  "challenge": "0x4d5e6f7a8b9c...",
  "commitmentIndex": 0
}</code></pre>
            <p><strong>Response:</strong></p>
            <pre><code class="language-json">{
  "status": "success",
  "proof": {
    "type": "schnorr-proof-2025",
    "commitment": "0x8f3a2b1c...",
    "challenge": "0x4d5e6f7a...",
    "response": "0x2b7c8d9e..."
  },
  "guardianId": "did:guardian:abc#key-1",
  "signature": "0x9a8b7c6d..."
}</code></pre>

            <h3>12.2 Type B Recovery Protocol</h3>
            <p><strong>Self-recovery:</strong></p>
            <pre><code class="language-http">POST /recover/seed HTTP/1.1
Host: wallet.example.com
Content-Type: application/json

{
  "protocol": "did-kr-recovery-v1",
  "recoveryId": "did:example:123#recovery-seedling",
  "seedPhrase": "abandon ability able about above ...",
  "derivationPath": "m/44'/0'/0'/0/0"
}</code></pre>
            <p><strong>Inheritance (VDF):</strong></p>
            <pre><code class="language-http">POST /recover/inherit HTTP/1.1
Host: beneficiary.example.com
Content-Type: application/json

{
  "protocol": "did-kr-recovery-v1",
  "recoveryId": "did:example:123#recovery-seedling",
  "vdfProof": {
    "output": "0x7c3d4e5f...",
    "proof": "0x2a5b6c7d...",
    "computationTime": "P32D",
    "platform": "amd-ryzen-7950x-2025"
  }
}</code></pre>

            <h3>12.3 Type C Recovery Protocol</h3>
            <p><strong>Phase 1 — Authentication Response:</strong></p>
            <pre><code class="language-json">{
  "status": "authenticated",
  "provider": "did:provider:one#mpc-node",
  "currentEpoch": 42,
  "lastRotation": "2024-05-15T10:30:00Z",
  "signature": "0x9a8b7c6d..."
}</code></pre>
            <p><strong>Phase 2 — MPC Signing Ceremony:</strong></p>
            <pre><code class="language-http">POST /mpc/sign HTTP/1.1
Host: provider1.example.com
Content-Type: application/json

{
  "protocol": "did-kr-recovery-v1",
  "sessionId": "sess_abc123def456",
  "operation": {
    "type": "update-did",
    "newDocument": { "id": "did:example:123", "...": "..." }
  },
  "commitment": "0x3e4f5a6b..."
}</code></pre>
        </section>

        <!-- Test Vectors -->
        <section id="test-vectors">
            <h2>13. Test Vectors <span class="tag tag-updated">UPDATED in rev 2.1</span></h2>

            <div class="corrected">
                <strong>All Type A vectors have been replaced.</strong> Previous vectors used incorrect 
                field parameters (secp256k1 N as group modulus). All values below are computed using 
                the group (p, q, g) from §7.0 and have been machine-verified against the reference 
                implementation (v2.1).
            </div>

            <h3>13.1 Type A — Feldman VSS</h3>
            <p><strong>Group parameters:</strong> (p, q, g) as in §7.0. All arithmetic in Z<sub>q</sub> for scalars, Z<sub>p</sub> for group elements.</p>
            <p><strong>Setup:</strong></p>
            <ul>
                <li>Secret: <code>s = 42</code></li>
                <li>Threshold: <code>t = 2</code>, Total: <code>n = 3</code></li>
                <li>Polynomial: <code>P(x) = 42 + 17·x</code> (over Z<sub>q</sub>)</li>
            </ul>
            <p><strong>Shares</strong> (<code>P(i) mod q</code>):</p>
            <div class="math-block">
s₁ = P(1) mod q = 59<br>
s₂ = P(2) mod q = 76<br>
s₃ = P(3) mod q = 93
            </div>
            <p><strong>Commitments</strong> (<code>g<sup>a<sub>j</sub></sup> mod p</code>):</p>
            <div class="math-block">
C₀ = 4<sup>42</sup> mod p<br>
C₁ = 4<sup>17</sup> mod p
            </div>
            <p><strong>Verification of s₃ (x=3)</strong> — previously failed in rev 1.x, now passes:</p>
            <div class="math-block">
LHS = 4<sup>93</sup> mod p<br>
RHS = C₀<sup>1</sup> · C₁<sup>3 mod q</sup> mod p  =  4<sup>42</sup> · 4<sup>51</sup> mod p  =  4<sup>93</sup> mod p  ✓
            </div>
            <p><strong>Recovery with s₁, s₂</strong> (Lagrange in Z<sub>q</sub>):</p>
            <div class="math-block">
L₁(0) = (0−2)/(1−2) mod q  =  2<br>
L₂(0) = (0−1)/(2−1) mod q  =  q−1<br>
s = 59·2 + 76·(q−1) mod q  =  118 − 76 mod q  =  42  ✓
            </div>

            <h3>13.2 Type A — Proactive Refresh <span class="tag tag-new">NEW in rev 2.1</span></h3>
            <p><strong>Continuing from §13.1</strong>, applying refresh polynomial <code>R(x) = 5·x</code> (R(0)=0):</p>
            <div class="math-block">
δ₁ = 5,  δ₂ = 10,  δ₃ = 15<br><br>
s₁ᶰᵉʷ = (59 + 5)  mod q = 64<br>
s₂ᶰᵉʷ = (76 + 10) mod q = 86<br>
s₃ᶰᵉʷ = (93 + 15) mod q = 108<br><br>
C₀ᶰᵉʷ = C₀                    (r₀ = 0, constant term forced zero)<br>
C₁ᶰᵉʷ = 4<sup>17</sup> · 4<sup>5</sup> mod p = 4<sup>22</sup> mod p<br><br>
Recovery with s₁ᶰᵉʷ, s₂ᶰᵉʷ:  s = 64·2 + 86·(q−1) mod q  =  128 − 86  =  42  ✓
            </div>

            <h3>13.3 Type B Test Vector</h3>
            <p><strong>Master Seed:</strong> <code>0x7f3a9b8c2d5e1f4a3b6c7d8e9f0a1b2c</code></p>
            <p><strong>Derivation Path:</strong> <code>m/44'/0'/0'/0/0</code></p>
            <p><strong>PBKDF2 salt:</strong> <code>"did-kr-salt:did:example:123"</code> (UTF-8), 100,000 iterations</p>
            <p><strong>Derived Private Key:</strong> <code>SHA-256(PBKDF2(seed, salt, 100000, 32))</code></p>

            <h3>13.4 Type C Test Vector</h3>
            <p><strong>fROST t=2, n=3</strong> (illustrative format; not actual key material):</p>
            <pre><code>Group Public Key: 0x3a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d...
Share 1 (epoch 1): 0x8c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f...
Share 2 (epoch 1): 0x2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e...
Share 3 (epoch 1): 0x7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c...</code></pre>
        </section>

        <!-- References -->
        <section id="references">
            <h2>14. References</h2>

            <h3>14.1 Normative References</h3>
            <dl>
                <dt>[DID-CORE]</dt>
                <dd>Decentralized Identifier Specification v1.0</dd>
                <dt>[RFC2119]</dt>
                <dd>Key words for use in RFCs</dd>
                <dt>[RFC8174]</dt>
                <dd>Ambiguity of Uppercase vs Lowercase in RFC2119</dd>
                <dt>[BIP32]</dt>
                <dd>Hierarchical Deterministic Wallets</dd>
                <dt>[BIP39]</dt>
                <dd>Mnemonic code for generating deterministic keys</dd>
                <dt>[FROST]</dt>
                <dd>Flexible Round-Optimized Schnorr Threshold Signatures</dd>
                <dt>[VDF]</dt>
                <dd>Verifiable Delay Functions — Boneh et al., 2018</dd>
                <dt>[FELDMAN]</dt>
                <dd>Feldman's Verifiable Secret Sharing — Feldman, 1987</dd>
                <dt>[SAFE-PRIME]</dt>
                <dd>Safe prime group parameter generation — NIST SP 800-57</dd>
            </dl>

            <h3>14.2 Informative References</h3>
            <dl>
                <dt>[SOCIAL-RECOVERY]</dt>
                <dd>Social Key Recovery for Self-Sovereign Identity</dd>
                <dt>[MPC-WALLET]</dt>
                <dd>Threshold Signatures for Cryptographic Wallets</dd>
                <dt>[TIME-LOCK]</dt>
                <dd>Time-Lock Encryption with Verifiable Delay Functions</dd>
                <dt>[ZKP-AUTH]</dt>
                <dd>Zero-Knowledge Proofs for Authentication</dd>
                <dt>[PROACTIVE]</dt>
                <dd>Proactive Secret Sharing — Herzberg et al., 1995</dd>
            </dl>
        </section>

        <!-- Acknowledgements -->
        <section id="acknowledgements">
            <h2>15. Acknowledgements</h2>
            <p>
                The editor would like to thank the members of the decentralized identity community for their 
                valuable feedback and contributions. Special thanks to the cryptographic reviewers who 
                identified the VSS group parameter error in revision 1.x, the privacy researchers who 
                contributed to the guardian privacy enhancements, and the implementers who caught the share 
                verification failure during integration testing.
            </p>
        </section>

        <!-- Appendices -->
        <section id="appendices">
            <h2>Appendices</h2>

            <h3>Appendix A: Implementation Checklist <span class="tag tag-updated">UPDATED in rev 2.1</span></h3>
            <table>
                <thead>
                    <tr>
                        <th>Requirement</th>
                        <th>Status</th>
                        <th>Notes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Type A: VSS group parameters (§7.0)</td>
                        <td><span class="status-done">✓ Complete</span></td>
                        <td>256-bit safe prime (p, q, g); machine-verified in ref impl v2.1</td>
                    </tr>
                    <tr>
                        <td>Type A: VSS share generation &amp; verification (§7.1)</td>
                        <td><span class="status-done">✓ Complete</span></td>
                        <td>Feldman VSS; all-indices self-check passes; verified across 5+ epochs</td>
                    </tr>
                    <tr>
                        <td>Type A: Proactive share refresh (§7.1.3)</td>
                        <td><span class="status-done">✓ Complete</span></td>
                        <td>Combined commitments verified; multi-epoch tested</td>
                    </tr>
                    <tr>
                        <td>Type A: ZKP implementation (§7.2)</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>Schnorr proofs of share knowledge</td>
                    </tr>
                    <tr>
                        <td>Type A: Guardian privacy (§9.2)</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>Hashed guardian identifiers</td>
                    </tr>
                    <tr>
                        <td>Type A: Social recovery path (reconstruct + re-key)</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>Guardian HTTP endpoints; authenticated share delivery protocol</td>
                    </tr>
                    <tr>
                        <td>Type B: HD key derivation (§5.2)</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>BIP-32 compatible</td>
                    </tr>
                    <tr>
                        <td>Type B: VDF implementation (§7.3)</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>Wesolowski or Pietrzak</td>
                    </tr>
                    <tr>
                        <td>Type C: fROST implementation (§7.5)</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>Threshold signatures</td>
                    </tr>
                    <tr>
                        <td>Type C: Epoch synchronization (§5.4)</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>Catch-up protocol; verifiable refresh transcripts between providers</td>
                    </tr>
                    <tr>
                        <td>Recovery-loop detection (§8.4)</td>
                        <td><span class="status-done">✓ Complete</span></td>
                        <td>DFS acyclicity check; <code>validate_recovery_graph()</code> in ref impl</td>
                    </tr>
                    <tr>
                        <td>Ephemeral key persistence</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>DB encryption key regenerated on restart; KMS integration required for production</td>
                    </tr>
                    <tr>
                        <td>API authentication (§12)</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>Flask endpoints open; JWT / API key middleware required before deployment</td>
                    </tr>
                    <tr>
                        <td>JSON-LD context (§11)</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>Schema updated for <code>vssGroupParameters</code> and <code>vssScheme</code>; publication pending</td>
                    </tr>
                    <tr>
                        <td>Test vectors (§13)</td>
                        <td><span class="status-done">✓ Complete</span></td>
                        <td>VSS, refresh, and recovery vectors machine-verified in rev 2.1</td>
                    </tr>
                    <tr>
                        <td>Security review</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>External audit pending</td>
                    </tr>
                    <tr>
                        <td>Privacy review</td>
                        <td><span class="status-open">☐ Open</span></td>
                        <td>Social graph analysis pending</td>
                    </tr>
                </tbody>
            </table>

            <h3>Appendix B: Changelog</h3>
            <table>
                <thead>
                    <tr>
                        <th>Revision</th>
                        <th>Section</th>
                        <th>Change</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>rev 2.1</code></td>
                        <td>§7.0 (new)</td>
                        <td>Defines mandatory VSS group parameters (p, q, g) — 256-bit safe prime, replacing  secp256k1 reuse.</td>
                    </tr>
                    <tr>
                        <td><code>rev 2.1</code></td>
                        <td>§7.1</td>
                        <td>Corrected Feldman VSS: scalar arithmetic in Z<sub>q</sub>, commitments in Z<sub>p</sub>, exponents reduced mod q.</td>
                    </tr>
                    <tr>
                        <td><code>rev 2.1</code></td>
                        <td>§7.1.3 (new)</td>
                        <td>Added normative Proactive Share Refreshment with combined commitment update equation.</td>
                    </tr>
                    <tr>
                        <td><code>rev 2.1</code></td>
                        <td>§13</td>
                        <td>Replaced all Type A test vectors; added Feldman refresh vector (§13.2).</td>
                    </tr>
                    <tr>
                        <td><code>rev 2.1</code></td>
                        <td>§5.1.4</td>
                        <td>DID Document representation updated with <code>vssGroupParameters</code> and <code>vssScheme</code> fields.</td>
                    </tr>
                    <tr>
                        <td><code>rev 2.1</code></td>
                        <td>§11</td>
                        <td>JSON-LD context updated with <code>vssGroupParameters</code> and <code>vssScheme</code> terms.</td>
                    </tr>
                    <tr>
                        <td><code>rev 2.1</code></td>
                        <td>Appendix A</td>
                        <td>VSS generation/verification and share refresh marked complete. Ephemeral key persistence, social recovery path, and API auth added as open items.</td>
                    </tr>
                    <tr>
                        <td><code>rev 1.x</code></td>
                        <td>All</td>
                        <td>Initial draft. VSS group parameters incorrectly specified (secp256k1 N reused as both scalar field and group modulus).</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Footer -->
        <div class="footer">
            <p>© 2026 Sirraya Labs. Licensed under the MIT License.</p>
            <p>Editor: Amir Hameed Mir · <a href="mailto:amir@sirraya.org">amir@sirraya.org</a></p>
            <p><a href="https://github.com/sirraya-labs/did-kr">GitHub Repository</a> · <a href="https://sirraya.org">sirraya.org</a></p>
        </div>
    </div>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'neutral',
            flowchart: {
                useMaxWidth: false,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                showSequenceNumbers: false,
                actorMargin: 50,
                height: 50
            }
        });

        hljs.highlightAll();
    </script>
</body>
</html>